<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinking_Out_Loud</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joe-xu.github.io/"/>
  <updated>2018-10-16T14:24:57.093Z</updated>
  <id>https://joe-xu.github.io/</id>
  
  <author>
    <name>Joe Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写一个Chrome扩展</title>
    <link href="https://joe-xu.github.io/2018/10/16/chrome-extention/"/>
    <id>https://joe-xu.github.io/2018/10/16/chrome-extention/</id>
    <published>2018-10-16T13:16:02.000Z</published>
    <updated>2018-10-16T14:24:57.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伪需求"><a href="#伪需求" class="headerlink" title="伪需求"></a>伪需求</h2><p>在公司里想要从外网电脑往内网电脑搬运资料<del>和一些代码</del>只能通过内部的IM里的“文件助手”中转，大大降低了面向搜索引擎编程的生产效率。所以亟需一个在浏览器右键菜单就可以直接发送选中文本等的Chrome插件。</p><h2 id="分析一下问题"><a href="#分析一下问题" class="headerlink" title="分析一下问题"></a>分析一下问题</h2><p>好在IM有Web端，我直接写一个扩展使用Chrome的API就可以操作数据了。初步设想是在页面内选中文本后，右键呼出菜单，菜单里有扩展的选项用IM里的接口将选中文本POST到“文件助手”的聊天记录里，然后信息就可以同步到内网机上了。</p><p>接着打开Chrome的控制台，往“文件助手”发几条信息，观察一下哪些接口是发送信息需要的。非常幸运的是，只有一个<code>sendMessage.do</code>是需要调用的，请求参数有<code>groupID</code>和<code>toUserId</code>，前者应该是标识一个会话，后者则是“文件助手”的uid了，余下的还有一些消息内容相关的参数。至于鉴权用的token则都放在了cookie里。另外，在测试这个接口的时候，我发现只要把<code>groupId</code>改为其他人的就可以乱入其他人的“文件助手”聊天窗口，不知道这算<em>BUG</em>还是<em>feature</em>，XD。</p><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome."></a>Chrome.<api></api></h2><p>其实跟着<a href="https://developer.chrome.com/extensions/getstarted" target="_blank" rel="noopener">官方的教程</a>走一遍就可以知道扩展的开发方式，主要是对<code>manifest.json</code>文件的配置还有Chrome API的调用。</p><p>首先，根据需求，我们需要操作右键菜单和发送网络请求，容易找到：</p><h3 id="chrome-contextMenus"><a href="#chrome-contextMenus" class="headerlink" title="chrome.contextMenus"></a>chrome.contextMenus</h3><p>这就是操作右键菜单的API，大概流程就是在扩展安装时配置菜单项，点击事件。</p><p>如下就配置好了一个右键菜单项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">        title: <span class="string">'Send "%s" to G'</span>,    <span class="comment">//  '%s' 是已选中文本的占位符</span></span><br><span class="line">        type: <span class="string">'normal'</span>,</span><br><span class="line">        id: SELECTION_MENU_ID,</span><br><span class="line">        contexts: [<span class="string">'selection'</span>] <span class="comment">//  在选中文本时出现，'image'则是在右击图像元素是出现</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>如下配置事件回调，后期增加了一个发送图片的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chrome.contextMenus.onClicked.addListener(<span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (info.menuItemId) &#123;</span><br><span class="line">            <span class="keyword">case</span> SELECTION_MENU_ID:</span><br><span class="line">                handleTextSelected(info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IMAGE_MENU_ID:</span><br><span class="line">                handleImgSelected(info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"Unexpected contextmenu ID"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="chrome-storage"><a href="#chrome-storage" class="headerlink" title="chrome.storage"></a>chrome.storage</h3><p>因为每个人的<code>groupId</code>都不同，不能硬编码到代码中，我们可以使用<a href="https://developer.chrome.com/apps/storage" target="_blank" rel="noopener">chrome.storage</a>存储到本地。</p><h3 id="跨域XMLHttpRequest"><a href="#跨域XMLHttpRequest" class="headerlink" title="跨域XMLHttpRequest"></a>跨域XMLHttpRequest</h3><p>发送网络请求遇到跨域问题时可以在<code>manifest.json</code>申请这个网站的权限来让扩展规避同源限制，也可以使用通配符的方式申请所有网站的权限，注意不能漏掉结尾的<code>/</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"My extension"</span>,</span><br><span class="line">  ...</span><br><span class="line">  "permissions": [</span><br><span class="line">    <span class="string">"*://*/"</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>在之后又增加了发送图片的功能，但是发送图片居然先后调用了4个接口才完成操作，3个以上的回调就是一个回调地狱了啊！不过好在可以用<code>Promise</code>包装调用，包装后如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">downloadImg(srcUrl)</span><br><span class="line">        .then(<span class="function">(<span class="params">imgBlob</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> fileName = srcUrl.substr(srcUrl.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>).split(<span class="string">'?'</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="string">'fileName'</span>: fileName, <span class="string">'imgBlob'</span>: imgBlob &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(uploadImg)</span><br><span class="line">        .then(getFileInfo)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> res.fileInfo;</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(sendImgMsg)</span><br><span class="line">        .then(saveFile);</span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>打算再加上一个将页面作为PDF发送的功能，不过这可能又是一个TODO。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;伪需求&quot;&gt;&lt;a href=&quot;#伪需求&quot; class=&quot;headerlink&quot; title=&quot;伪需求&quot;&gt;&lt;/a&gt;伪需求&lt;/h2&gt;&lt;p&gt;在公司里想要从外网电脑往内网电脑搬运资料&lt;del&gt;和一些代码&lt;/del&gt;只能通过内部的IM里的“文件助手”中转，大大降低了面向搜索引
      
    
    </summary>
    
    
      <category term="tools" scheme="https://joe-xu.github.io/tags/tools/"/>
    
      <category term="Javascript" scheme="https://joe-xu.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#7</title>
    <link href="https://joe-xu.github.io/2018/10/10/reading-the-go-programming-language-07/"/>
    <id>https://joe-xu.github.io/2018/10/10/reading-the-go-programming-language-07/</id>
    <published>2018-10-10T13:45:14.000Z</published>
    <updated>2018-10-10T14:05:02.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第八章-goroutine和通道"><a href="#第八章-goroutine和通道" class="headerlink" title="第八章 goroutine和通道"></a>第八章 goroutine和通道</h2><h3 id="lt-P225-gt"><a href="#lt-P225-gt" class="headerlink" title="&lt; P225 &gt;"></a>&lt; P225 &gt;</h3><ul><li>同类型的<code>chan</code>可以用<code>==</code>比较，当两者指向同一<em>channel data structure</em>时结果为真；</li><li>容量大于零都算<em>buffered channel</em>；<code>cap</code>为零即没有缓冲，发送方要一直等到接收方接收；</li></ul><h3 id="lt-P229-gt"><a href="#lt-P229-gt" class="headerlink" title="&lt; P229 &gt;"></a>&lt; P229 &gt;</h3><ul><li><em>channel</em>被关闭后，后续的发送会引发<code>panic</code>，而后续的接收只会得到零值；可以增加第二个接受布尔类型的返回值检测是否关闭，更简便的方法是用<code>range</code>，<em>channel</em>关闭后<code>range</code>循环也结束；</li><li><strong>关闭一个已关闭的<em>channel</em>或值为<code>nil</code>的都会引发<code>panic</code></strong>；</li><li>当GC检测到<em>channel</em>是<em>unreachable</em>时，不管关闭与否都会将其GC，所以关闭channel不是必要的；</li></ul><h3 id="lt-P230-gt"><a href="#lt-P230-gt" class="headerlink" title="&lt; P230 &gt;"></a>&lt; P230 &gt;</h3><ul><li>加上助记符<code>&lt;-</code>变成<em>unidirectional channel</em>，如<code>&lt;-chan T</code>或<code>chan&lt;- T</code>，表示数据只能单方向传输，会在编译时检查是否有违法的操作；</li><li>对<em>read-only</em>的<em>channel</em>使用<code>close</code>方法会引发编译错误；</li><li>存在从双向<em>channel</em>到单向的隐式转换，但这种转换是不可逆的；</li></ul><h3 id="lt-P232-gt"><a href="#lt-P232-gt" class="headerlink" title="&lt; P232 &gt;"></a>&lt; P232 &gt;</h3><ul><li>用<code>len</code>和<code>cap</code>方法查看<em>channel</em>的当前缓存元素个数和容量；</li><li>不要把<em>channel</em>当作队列使用，因为<em>channel</em>和当前<em>goroutine</em>的时序联系很深，可能会阻塞运行；</li><li><em>goroutine leak</em>发生在<em>goroutine</em>向一个<em>channel</em>发送数据时被阻塞，而该<em>channel</em>之后也不会被取出数据，所以阻塞一直持续；</li></ul><h3 id="lt-P236-gt"><a href="#lt-P236-gt" class="headerlink" title="&lt; P236 &gt;"></a>&lt; P236 &gt;</h3><p><strong>使用匿名函数的<em>goroutine</em>也要注意变量的捕获，应该用传参或者新的局部变量捕获</strong>；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> <span class="string">"abcdefg"</span> &#123;</span><br><span class="line">        <span class="comment">//s := s // 用新的局部变量</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c\n"</span>, s)</span><br><span class="line">            ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;(s) <span class="comment">// 或者传参</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> <span class="string">"abcdefg"</span> &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-P245-gt"><a href="#lt-P245-gt" class="headerlink" title="&lt; P245 &gt;"></a>&lt; P245 &gt;</h3><ul><li>没有<code>case</code>的<code>select</code>结构会<em>wait forever</em>；</li><li>当多个<code>case</code>都<em>ready</em>时，<code>select</code>随机选择一个运行；</li><li>使用<code>time.Tick</code>函数会新建一个<em>goroutine</em>，只建议全局都用到的时候才使用，不然会造成<em>goroutine leak</em>；一般推荐使用<code>time.NewTicker</code>,使用返回对象的<code>Stop</code>方法终止计时<em>goroutine</em>；</li><li><code>select</code>里的<code>case</code>只能存在<em>channel</em>的接收或发送操作；</li><li>对值为<code>nil</code>的<em>channel</em>的接收或发送都永远阻塞；配合<code>select</code>可以作为选项开关；</li><li><code>select</code>加入<code>default</code>可以用作对<em>channel</em>的查询（<em>polling channel</em>）；否则会停留直到其中一个<code>case</code>可行；</li></ul><h3 id="lt-P252-gt"><a href="#lt-P252-gt" class="headerlink" title="&lt; P252 &gt;"></a>&lt; P252 &gt;</h3><p>poll一个<em>closed channel</em>可以取得零值（以及<code>false</code>）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第八章-goroutine和通道&quot;&gt;&lt;a href=&quot;#第八章-goroutine和通道&quot; class=&quot;headerlink&quot; title=&quot;第八章 goroutine和通道&quot;&gt;&lt;/a&gt;第八章 goroutine和通道&lt;/h2&gt;&lt;h3 id=&quot;lt-P225-g
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SSH端口转发</title>
    <link href="https://joe-xu.github.io/2018/10/08/ssh-tunnel-port-forwarding/"/>
    <id>https://joe-xu.github.io/2018/10/08/ssh-tunnel-port-forwarding/</id>
    <published>2018-10-08T13:14:24.000Z</published>
    <updated>2018-10-08T14:17:11.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一种场景"><a href="#一种场景" class="headerlink" title="一种场景"></a>一种场景</h2><p>想象这么一种场景，你在远程主机上刚装好Docker，启动Docker Daemon之后却被断开了ssh连接。仔细一想，原来daemon启动之后创建的网桥默认是<code>172.17.0.0/16</code>，正好和办公室的网段冲突了……<br>恭喜发财！这间办公室的电脑都不能连上你的服务器了，而且是内网服务器所以手机也是不行，但你想到你隔壁老哥的服务器是可以访问你的服务器的，可是问题是你又不好意思登录他的服务器随便乱搞。<br>那么端口转发就是我最后的救命稻草了。</p><h2 id="用ssh来转发端口"><a href="#用ssh来转发端口" class="headerlink" title="用ssh来转发端口"></a>用ssh来转发端口</h2><p>赞美SSH！！</p><h3 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h3><p>用<code>-L</code>选项来开启本地端口转发：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh -L [bind_address:]port:host:hostport [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>举个例子，我们有个服务器<code>A.com</code>可以访问<code>google.com</code>，现在要把我们本机的<code>9000</code>端口接收到的请求转发到<code>google.com</code>，可以这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh -L 9000:google.com:80 user@A.com</span><br></pre></td></tr></table></figure><p>现在我们打开浏览器访问<code>localhost:9000</code>就可以看一看谷歌首页了。</p><h3 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h3><p>和本地转发相反：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh -R [bind_address:]port:host:hostport [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>如果我们本机在内网中且运行了一个Web服务，监听端口是<code>9000</code>，现在我们想让外网机器访问这个服务但苦于没有公网IP。<br>除了配置NAT之外，我们可以用ssh的远程转发。假设我们在外网有一台服务器<code>B.com</code>，有公网IP那种，我们可以这样:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh -R 9000:localhost:3000 user@B.com</span><br></pre></td></tr></table></figure><p>注意，上面命令中的<code>localhost</code>是从<code>B.com</code>的角度看的，也就是将<code>B.com</code>在<code>3000</code>端口接收到的请求转发到我们本机的<code>9000</code>端口。所以外网机器访问<code>B.com:3000</code>就可以访问到我们内网本机的服务。</p><p>另外，远程转发默认是关闭的。我们要在本地主机<code>/etc/ssh/sshd_config</code>设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GatewayPorts yes</span><br></pre></td></tr></table></figure><p>再重启ssh服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; service sshd restart</span><br></pre></td></tr></table></figure><h3 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh -D [bind_address:]port [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>这个用个例子就能知道怎么用了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh -D 1080 C.com</span><br></pre></td></tr></table></figure><p>假如<code>C.com</code>能爱国上网，那么我们设置代理<code>localhost:1080</code>就可以访问谷歌。当然，本来这个是用来加密连接的。</p><h3 id="可以配合食用的选项"><a href="#可以配合食用的选项" class="headerlink" title="可以配合食用的选项"></a>可以配合食用的选项</h3><ul><li><code>-n</code>：将标准输入重定向到<code>/dev/null</code>，就是不接收输入，ssh在后台运行的时候必须设置这个；</li><li><code>-N</code>：不执行命令，正适合做端口转发；</li><li><code>-f</code>：让ssh在后台运行，隐式使用了<code>-n</code>，适合需要输入密码再转入后台运行的情景；</li><li><code>-T</code>：不分配TTY；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.trackets.com/2014/05/17/ssh-tunnel-local-and-remote-port-forwarding-explained-with-examples.html" target="_blank" rel="noopener">https://blog.trackets.com/2014/05/17/ssh-tunnel-local-and-remote-port-forwarding-explained-with-examples.html</a></li><li><a href="https://blog.csdn.net/blade2001/article/details/8877250" target="_blank" rel="noopener">https://blog.csdn.net/blade2001/article/details/8877250</a></li><li><a href="https://stackoverflow.com/questions/42505339/why-use-t-with-ssh" target="_blank" rel="noopener">https://stackoverflow.com/questions/42505339/why-use-t-with-ssh</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一种场景&quot;&gt;&lt;a href=&quot;#一种场景&quot; class=&quot;headerlink&quot; title=&quot;一种场景&quot;&gt;&lt;/a&gt;一种场景&lt;/h2&gt;&lt;p&gt;想象这么一种场景，你在远程主机上刚装好Docker，启动Docker Daemon之后却被断开了ssh连接。仔细一想，原来d
      
    
    </summary>
    
    
      <category term="tools" scheme="https://joe-xu.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#6</title>
    <link href="https://joe-xu.github.io/2018/10/07/reading-the-go-programming-language-06/"/>
    <id>https://joe-xu.github.io/2018/10/07/reading-the-go-programming-language-06/</id>
    <published>2018-10-07T13:25:06.000Z</published>
    <updated>2018-10-07T13:54:33.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><h3 id="lt-P176-gt"><a href="#lt-P176-gt" class="headerlink" title="&lt; P176 &gt;"></a>&lt; P176 &gt;</h3><p>在操作<code>interface</code>时，编译器不会对<code>T</code>和<code>*T</code>隐式转换，没有了简便的语法糖，因此<code>T</code>不拥有<code>*T</code>的方法；</p><h3 id="lt-P182-gt"><a href="#lt-P182-gt" class="headerlink" title="&lt; P182 &gt;"></a>&lt; P182 &gt;</h3><ul><li><code>interface</code>由两部分组成，<code>type</code>存储<code>type descriptor</code>，<code>value</code>一般存储指针；<code>interface</code>调用方法是间接调用，先根据<code>type descriptor</code>找到方法地址，再将<code>value</code>拷贝作为接收器传入；</li><li><code>interface</code>可以两两比较或与<code>nil</code>比较；但是如果<code>value</code>中的类型是不可比较的，会发生<code>panic</code>；<strong>只有<code>type</code>与<code>type descriptor</code>都为<code>nil</code>时，与<code>nil</code>的比较才为真(受人诟病的坑之一)；</strong></li><li>调试时可以用<code>%T</code>打印<code>type descriptor</code>，<code>fmt</code>通过反射获取；</li></ul><h3 id="lt-P188-gt"><a href="#lt-P188-gt" class="headerlink" title="&lt; P188 &gt;"></a>&lt; P188 &gt;</h3><p><code>Sort.Reverse</code>的实现很巧妙，用结构体<code>reverse</code>又包装了<code>interface</code>，<code>reverse</code>的<code>Less</code>方法调用匿名内嵌字段<code>interface</code>的<code>Less</code>方法，而<code>Reverse</code>函数又返回满足<code>sort.Interface</code>的<code>reverse</code>结构体；</p><h3 id="lt-P191-195-gt"><a href="#lt-P191-195-gt" class="headerlink" title="&lt; P191-195 &gt;"></a>&lt; P191-195 &gt;</h3><ul><li><code>http.Handler</code>是基本的<code>interface</code>，只要求<code>ServerHTTP</code>方法，作为<code>ListenAndServe</code>的第二个参数；</li><li>为了分离逻辑，<code>net/http</code>包提供了<code>ServeMux</code>，将多个<code>http.Handler</code>集合为一个；在传入方法时用<code>http.HandlerFunc</code>将方法转为<code>http.Handler</code>，注意<code>http.HandlerFunc</code>是一种函数类型，作为<code>ServerHTTP</code>接收器，满足<code>http.Handler</code>接口，并在内部调用自己；</li><li><code>net/http</code>提供了默认的<code>ServeMux</code>，即<code>DefaultServeMux</code>，在  <code>ListenAndServe</code>第二参数传入<code>nil</code>即可，用<code>http.HandeFunc</code>添加路由；</li><li>注意每个请求都会单独创建一个<code>goroutine</code>；</li></ul><h3 id="lt-P196-gt"><a href="#lt-P196-gt" class="headerlink" title="&lt; P196 &gt;"></a>&lt; P196 &gt;</h3><p><code>errors.New</code>返回<code>errorString</code>结构体的指针，所以两个<code>New</code>出来的<code>error</code>比较是不相等的；</p><h3 id="lt-P205-gt"><a href="#lt-P205-gt" class="headerlink" title="&lt; P205 &gt;"></a>&lt; P205 &gt;</h3><ul><li>类型断言分两种：<ol><li><code>x.(T)</code>，假如<code>T</code>是实际类型（concrete type）并且<code>x</code>为<code>interface</code>，断言检测通过返回<code>x</code>的<code>dynamic value</code>，类型当然是<code>T</code>，检测失败引发<code>panic</code>；</li><li>假如<code>T</code>是<code>interface</code>，断言检测会检查<code>x</code>的<code>dynamic type</code>是否满足<code>T</code>，返回结果满足<code>T</code>，一般结果的方法集更大，失败同样引起<code>panic</code>；</li></ol></li><li>无论<code>T</code>是何种类型，对<code>nil</code>的断言永远失败；</li><li>期望两个返回值的断言检测失败不会<code>panic</code>，额外返回值为布尔值表示是否成功，失败时第一个返回值为该类型零值；</li></ul><h3 id="lt-P212-gt"><a href="#lt-P212-gt" class="headerlink" title="&lt; P212 &gt;"></a>&lt; P212 &gt;</h3><p>在<code>type switch</code>中，提取值之后的变量类型与当前<code>case</code>相同，除了多个条件并列时还是<code>interface{}</code>；(另外企图用<code>%T</code>打印<code>interface{}</code>类型的我简直犯傻，本来打印方法的传参就是<code>…interface{}</code>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第七章-接口&quot;&gt;&lt;a href=&quot;#第七章-接口&quot; class=&quot;headerlink&quot; title=&quot;第七章 接口&quot;&gt;&lt;/a&gt;第七章 接口&lt;/h2&gt;&lt;h3 id=&quot;lt-P176-gt&quot;&gt;&lt;a href=&quot;#lt-P176-gt&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#5</title>
    <link href="https://joe-xu.github.io/2018/10/01/reading-the-go-programming-language-05/"/>
    <id>https://joe-xu.github.io/2018/10/01/reading-the-go-programming-language-05/</id>
    <published>2018-10-01T13:10:39.000Z</published>
    <updated>2018-10-01T13:53:12.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><p>我认为我们还是有必要先区分函数(function)和方法(method)。两者最明显的区别就是方法是和对象绑定的。下面是<a href="https://stackoverflow.com/a/155655" target="_blank" rel="noopener">Stackoverflow上面的高票回答</a>:</p><blockquote><p>A <strong>function</strong> is a piece of code that is called by name. It can be passed data to operate on (i.e. the parameters) and can optionally return data (the return value). All data that is passed to a function is explicitly passed.</p><p>A <strong>method</strong> is a piece of code that is called by a name that is associated with an object. In most respects it is identical to a function except for two key differences:</p><ol><li>A method is implicitly passed the object on which it was called.</li><li>A method is able to operate on data that is contained within the class (remembering that an object is an instance of a class - the class is the definition, the object is an instance of that data).</li></ol></blockquote><p>函数的传参和返回值都是显式的，而方法则可以在内部访问、操作对象的成员变量，另外还有作用域等差异，因编程语言不同而各异。</p><h2 id="第六章-方法"><a href="#第六章-方法" class="headerlink" title="第六章 方法"></a>第六章 方法</h2><h3 id="lt-P156-gt"><a href="#lt-P156-gt" class="headerlink" title="&lt; P156 &gt;"></a>&lt; P156 &gt;</h3><ul><li>方法名不能与字段相同；</li><li>可以给同一个包内的任何具名类型声明方法，只要它的底层类型不是指针或<code>interface</code>；</li></ul><h3 id="lt-P158-gt"><a href="#lt-P158-gt" class="headerlink" title="&lt; P158 &gt;"></a>&lt; P158 &gt;</h3><ul><li>如果一个方法的接收器是指针，我们可以直接用变量调用（不用手动解引用），编译器会进行隐式转换；所以如果用不能获取到地址的接收器调用编译器会报错(不通过变量直接使用一个值，一般都无法进行寻址)；</li><li>如果类型<code>T</code>的方法有指针接收器类型，要避免拷贝<code>T</code>的实例，因为会违反内部不变原则；例如共享底层空间时，会发生无法预料的结果；</li><li><code>nil</code>也是合法的接收器值；</li></ul><h3 id="lt-P163-gt"><a href="#lt-P163-gt" class="headerlink" title="&lt; P163 &gt;"></a>&lt; P163 &gt;</h3><ul><li>编译器自顶向下查找方法，先是类型自身定义的，再到内嵌类型提升（promoted）上来的，然后是内嵌类型的再下一级……如果同一级中有同名方法，编译器会报错；</li></ul><h3 id="lt-P164-gt"><a href="#lt-P164-gt" class="headerlink" title="&lt; P164 &gt;"></a>&lt; P164 &gt;</h3><ul><li>可以用<code>t.f</code>或<code>(*t).f</code>生成方法值(<em>method value</em>),会绑定当前接收器，之后可以像普通函数一样调用；</li><li>可以用<code>T.f</code>或<code>(*T).f</code>生成方法表达式(<em>method expression</em>),在第一个参数指定接收器；</li></ul><p>上面两条在魔改公用库时非常好用，能保证API向后兼容 :D</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题外&quot;&gt;&lt;a href=&quot;#题外&quot; class=&quot;headerlink&quot; title=&quot;题外&quot;&gt;&lt;/a&gt;题外&lt;/h2&gt;&lt;p&gt;我认为我们还是有必要先区分函数(function)和方法(method)。两者最明显的区别就是方法是和对象绑定的。下面是&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的GROUP_CONCAT()</title>
    <link href="https://joe-xu.github.io/2018/09/28/group-concat-in-mysql/"/>
    <id>https://joe-xu.github.io/2018/09/28/group-concat-in-mysql/</id>
    <published>2018-09-28T13:30:39.000Z</published>
    <updated>2018-09-28T14:57:59.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天要在负责维护的内部系统中做一次数据迁移（<del>心跳加速</del>），表结构不变，而是改变一些字段的存取方式。第一次用到了<a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat" target="_blank" rel="noopener">MySQL里的<code>GROUP_CONCAT()</code>函数</a>，在这里记录一下。</p><h2 id="准备测试表-amp-数据"><a href="#准备测试表-amp-数据" class="headerlink" title="准备测试表&amp;数据"></a>准备测试表&amp;数据</h2><p>下面是简单的测试用表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tab_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> mediumint(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`pid`</span> mediumint(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">char</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`str_1`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`str_2`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>准备测试数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tab_test`</span> <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'v1'</span>,<span class="string">"Joe"</span>,<span class="string">"Tag1"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tab_test`</span> <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="string">'v1'</span>,<span class="string">"Ben"</span>,<span class="string">"Tag2"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tab_test`</span> <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">1</span>,<span class="string">'v2'</span>,<span class="string">"Lily"</span>,<span class="string">"Tag3"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tab_test`</span> <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">2</span>,<span class="string">'v1'</span>,<span class="string">"Alice"</span>,<span class="string">"Tag4"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tab_test`</span> <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">2</span>,<span class="string">'v2'</span>,<span class="string">"Buddy"</span>,<span class="string">"Tag5"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tab_test`</span> <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="number">2</span>,<span class="string">'v1'</span>,<span class="string">"Coco"</span>,<span class="string">"Tag6"</span>);</span><br></pre></td></tr></table></figure><p>具体的需求就是按<code>pid</code>分组且按<code>id</code>增序，把每组的<code>str_1</code>和<code>str_2</code>合并到该组第一条记录的<code>str_1</code>中，值得注意的是，<code>version</code>不同的记录不能合并到一起。</p><p>刚开始还在考虑是不是需要写py脚本来操作，不过还好有<code>GROUP_CONCAT()</code>，现在只要写SQL就足够了。</p><h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><p>来看看<code>GROUP_CONCAT()</code>的用法和示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GROUP_CONCAT([DISTINCT] expr [,expr ...]</span><br><span class="line">             [ORDER BY &#123;unsigned_integer | col_name | expr&#125;</span><br><span class="line">                 [ASC | DESC] [,col_name ...]]</span><br><span class="line">             [SEPARATOR str_val])</span><br></pre></td></tr></table></figure><p>两种用法都可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_name,</span><br><span class="line">         <span class="keyword">GROUP_CONCAT</span>(test_score)</span><br><span class="line">       <span class="keyword">FROM</span> student</span><br><span class="line">       <span class="keyword">GROUP</span> <span class="keyword">BY</span> student_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> student_name,</span><br><span class="line">         <span class="keyword">GROUP_CONCAT</span>(<span class="keyword">DISTINCT</span> test_score</span><br><span class="line">                      <span class="keyword">ORDER</span> <span class="keyword">BY</span> test_score <span class="keyword">DESC</span> SEPARATOR <span class="string">' '</span>)</span><br><span class="line">       <span class="keyword">FROM</span> student</span><br><span class="line">       <span class="keyword">GROUP</span> <span class="keyword">BY</span> student_name;</span><br></pre></td></tr></table></figure><h2 id="撸起袖子就是干"><a href="#撸起袖子就是干" class="headerlink" title="撸起袖子就是干"></a>撸起袖子就是干</h2><p>依葫芦画瓢先试试效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`id`</span>,<span class="keyword">GROUP_CONCAT</span>(</span><br><span class="line"><span class="string">`str_1`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span></span><br><span class="line">SEPARATOR <span class="string">','</span></span><br><span class="line">) <span class="string">`merged_str_1`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`tab_test`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`pid`</span>,<span class="string">`version`</span>;</span><br></pre></td></tr></table></figure><p>输出结果也很棒棒，合乎预期，按<code>pid</code>和<code>version</code>分组然后拼接<code>str_1</code>到每组第一条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+--------------+</span><br><span class="line">| id | merged_str_1 |</span><br><span class="line">+----+--------------+</span><br><span class="line">|  1 | Joe,Ben      |</span><br><span class="line">|  3 | Lily         |</span><br><span class="line">|  4 | Alice,Coco   |</span><br><span class="line">|  5 | Buddy        |</span><br><span class="line">+----+--------------+</span><br></pre></td></tr></table></figure><p>继续拼装：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">`tab_test`</span> t1,(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="string">`id`</span>,<span class="keyword">CONCAT_WS</span>(</span><br><span class="line">    <span class="string">','</span>,</span><br><span class="line">    <span class="keyword">TRIM</span>(<span class="string">','</span> <span class="keyword">FROM</span> <span class="keyword">GROUP_CONCAT</span>(<span class="string">`str_1`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> SEPARATOR <span class="string">','</span>)),</span><br><span class="line">    <span class="keyword">TRIM</span>(<span class="string">','</span> <span class="keyword">FROM</span> <span class="keyword">GROUP_CONCAT</span>(<span class="string">`str_2`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`id`</span> SEPARATOR <span class="string">','</span>)) </span><br><span class="line">    ) <span class="string">`merged_str_1`</span></span><br><span class="line">    <span class="keyword">FROM</span> <span class="string">`tab_test`</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`pid`</span>,<span class="string">`version`</span>) t2</span><br><span class="line"><span class="keyword">SET</span> t1.str_1 = t2.merged_str_1</span><br><span class="line"><span class="keyword">WHERE</span> t1.id = t2.id;</span><br></pre></td></tr></table></figure><p>更新后的表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+-----+---------+----------------------+-------+</span><br><span class="line">| id | pid | version | str_1                | str_2 |</span><br><span class="line">+----+-----+---------+----------------------+-------+</span><br><span class="line">|  1 |   1 | v1      | Joe,Ben,Tag1,Tag2    | Tag1  |</span><br><span class="line">|  2 |   1 | v1      | Ben                  | Tag2  |</span><br><span class="line">|  3 |   1 | v2      | Lily,Tag3            | Tag3  |</span><br><span class="line">|  4 |   2 | v1      | Alice,Coco,Tag4,Tag6 | Tag4  |</span><br><span class="line">|  5 |   2 | v2      | Buddy,Tag5           | Tag5  |</span><br><span class="line">|  6 |   2 | v1      | Coco                 | Tag6  |</span><br><span class="line">+----+-----+---------+----------------------+-------+</span><br></pre></td></tr></table></figure><p>那么剩下的就是单纯的删除工作了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;今天要在负责维护的内部系统中做一次数据迁移（&lt;del&gt;心跳加速&lt;/del&gt;），表结构不变，而是改变一些字段的存取方式。第一次用到了&lt;a hr
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://joe-xu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统负载</title>
    <link href="https://joe-xu.github.io/2018/09/27/linux-load-averages/"/>
    <id>https://joe-xu.github.io/2018/09/27/linux-load-averages/</id>
    <published>2018-09-27T14:18:18.000Z</published>
    <updated>2018-09-27T15:35:59.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html" target="_blank" rel="noopener">http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html</a></p></blockquote><h2 id="初识负载"><a href="#初识负载" class="headerlink" title="初识负载"></a>初识负载</h2><p>我们平时使用<code>top</code>或者<code>uptime</code>时可以看到打印输出的系统平均负载（方便起见，后文都简称负载），分别是1分钟、5分钟和15分钟，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 22:20:29 up 9 min,  0 users,  load average: 0.52, 0.58, 0.59</span><br></pre></td></tr></table></figure><p>我们一般这样解读负载：</p><ul><li>如果负载是<code>0.0</code>，那么系统就是空闲状态；</li><li>如果1分钟负载比5分钟或15分钟负载大，易见系统负载正在增长；</li><li>反之，如果1分钟负载比5分钟或15分钟负载小，那么系统负载正在降低；</li><li>如果负载高于CPU核数，那么系统中可能存在性能问题；</li></ul><p>但是系统负载到底是怎么统计的呢？</p><hr><p>先说结论：</p><p>在Linux中，负载是单位时间内的运行及等待运行的任务数，包含<code>TASK_UNINTERRUPTIBLE</code>状态（不受中断信号影响，一般是等待I/O和互斥锁的任务，在<code>ps</code>和<code>top</code>用<code>D</code>作标记）中的任务。也就是说，Linux的系统负载不仅仅是CPU的使用，还把I/O等系统资源加入到了统计中。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么要将CPU外的资源纳入统计范围，下面是对这次commit的说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">From: Matthias Urlichs &lt;urlichs@smurf.sub.org&gt;</span><br><span class="line">Subject: Load average broken ?</span><br><span class="line">Date: Fri, 29 Oct 1993 11:37:23 +0200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The kernel only counts &quot;runnable&quot; processes when computing the load average.</span><br><span class="line">I don&apos;t like that; the problem is that processes which are swapping or</span><br><span class="line">waiting on &quot;fast&quot;, i.e. noninterruptible, I/O, also consume resources.</span><br><span class="line"></span><br><span class="line">It seems somewhat nonintuitive that the load average goes down when you</span><br><span class="line">replace your fast swap disk with a slow swap disk...</span><br><span class="line"></span><br><span class="line">Anyway, the following patch seems to make the load average much more</span><br><span class="line">consistent WRT the subjective speed of the system. And, most important, the</span><br><span class="line">load is still zero when nobody is doing anything. ;-)</span><br></pre></td></tr></table></figure><p>也就说如果仅统计CPU的使用，一个重I/O的程序从高速磁盘转到低速硬盘运行时，系统负载就会出现下降的情形。显然这从用户的角度看是不合理的，而且不便于反映系统性能问题，所以应该把整个系统的资源使用纳入统计范围。</p><h2 id="更好的度量项"><a href="#更好的度量项" class="headerlink" title="更好的度量项"></a>更好的度量项</h2><p>虽然系统负载考虑了整个系统资源，但是也不能单纯用负载除以CPU核数的方法判定一个系统的运行状况，这个时候用检验值去做平行比较反而更好。</p><p>因为负载值的模凌两可，我们可以考虑用下列的值来代替：</p><blockquote><ul><li>per-CPU utilization: eg, using mpstat -P ALL 1</li><li>per-process CPU utilization: eg, top, pidstat 1, etc.</li><li>per-thread run queue (scheduler) latency: eg, in /proc/PID/schedstats, delaystats, perf sched</li><li>CPU run queue latency: eg, in /proc/schedstat, perf sched.</li><li>CPU run queue length: eg, using vmstat 1 and the ‘r’ column.</li></ul></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里只摘抄转译了原文部分内容，并没有全部搬运。有兴趣继续深入的同学可以在原文阅览更多内容，地址见文首。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用VScode + rmate编辑远程文件</title>
    <link href="https://joe-xu.github.io/2018/09/25/edit-remote-file/"/>
    <id>https://joe-xu.github.io/2018/09/25/edit-remote-file/</id>
    <published>2018-09-25T14:30:46.000Z</published>
    <updated>2018-09-25T15:06:37.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一直用着便宜的VPS，可惜就是延迟太高，每次用<code>vim</code>总能有一秒多的lag，但生活总不能将就下去，找了一种简单好用的编辑远程文件方法，记录一下。</p><h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h2><p>在远程主机安装<a href="https://github.com/textmate/rmate" target="_blank" rel="noopener">rmate</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -Lo ~/bin/rmate https://raw.githubusercontent.com/textmate/rmate/master/bin/rmate</span><br><span class="line">&gt; chmod a+x ~/bin/rmate</span><br></pre></td></tr></table></figure><p>在本地主机VScode中安装插件<a href="https://marketplace.visualstudio.com/items?itemName=rafaelmaiolla.remote-vscode" target="_blank" rel="noopener">remote-vscode</a>;</p><p>编辑本地主机<code>~/.ssh/config</code>文件，其中<code>52698</code>是rmate的默认端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host vps</span><br><span class="line">        User root</span><br><span class="line">        HostName xx.xx.xx.xx</span><br><span class="line">        Port xxxx</span><br><span class="line">        RemoteForward 52698 localhost:52698</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>首先要确保VScode中的插件的服务器已经运行，如果要自启可以设置<code>&quot;remote.onstartup&quot;: true</code>，或者<code>ctrl + shift + P</code>后选择<code>Remote: Start Server</code>手动启动服务器；</p></li><li><p>如果你要在远程主机上想要编辑一个文件：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh vps</span><br><span class="line">&gt; rmate /path/to/fileA</span><br></pre></td></tr></table></figure></li><li><p>现在可以在VScode自动弹出来文件<code>fileA</code>中自由编辑了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一直用着便宜的VPS，可惜就是延迟太高，每次用&lt;code&gt;vim&lt;/code&gt;总能有一秒多的lag，但生活总不能将就下去，找了一种简单好用的
      
    
    </summary>
    
    
      <category term="tools" scheme="https://joe-xu.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>我是如何用掉一天的：OpenWRT配v2ray</title>
    <link href="https://joe-xu.github.io/2018/09/22/openwrt-plus-v2ray/"/>
    <id>https://joe-xu.github.io/2018/09/22/openwrt-plus-v2ray/</id>
    <published>2018-09-22T14:45:35.000Z</published>
    <updated>2018-09-25T15:04:18.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个小目标"><a href="#一个小目标" class="headerlink" title="一个小目标"></a>一个小目标</h1><p>今天把我的小Y从<em>lede-17.01</em>升级到了<em>openwrt-18.06.1</em>。对，lede又重新和openwrt合并了，XP。<br>很欣喜的是发现默认主题居然变好看了，交互体验也提升了很多，<del>这个开源小组终于有美工了</del>，升级过程暂且不表，今天我的小目标是在路由器上用<a href="https://www.v2ray.com/" target="_blank" rel="noopener">v2ray</a>搭好爱国透明代理。</p><p>然而第一步就掉了链子，<a href="https://wiki.openwrt.org/doc/howto/wget-ssl-certs" target="_blank" rel="noopener">openwrt中默认的<code>wget</code>命令是由busybox提供的</a>，不支持https，所以需要重新安装一个。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; opkg update</span><br><span class="line">&gt; opkg install wget</span><br></pre></td></tr></table></figure><p>然后就可以高高兴兴去下二进制安装包了，不料这mipsle的安装包竟然有17MB，一个主程序和辅助工具再加上IP数据集，我的小Y只有16MB的Flash，<del>真是天要亡我</del>。还是不死心，go在编译时去掉符号表能省不少空间，还能再挤挤，果然在谷歌第一页就翻到了大牛留下的笔记：</p><blockquote><p><a href="https://gobomb.github.io/post/cross-complie-v2ray/" target="_blank" rel="noopener">https://gobomb.github.io/post/cross-complie-v2ray/</a></p></blockquote><p>多亏大牛我才想起在openwrt官网下载的系统升级固件默认是没开FPU支持的，运行go程序会报<code>Illegal instruction</code>，就是说我要从固件开始自己编译，<del>抬头望天</del>。</p><h1 id="挣扎"><a href="#挣扎" class="headerlink" title="挣扎"></a>挣扎</h1><p>翻出了还在15.05-cc版的本地仓库，用30KB的平均速度pull到了最新的代码，长征第一步。</p><p>我沿用了之前搭建的环境，如果有需要从零开始搭建的同学可以参考<a href="https://openwrt.org/docs/guide-developer/build-system/install-buildsystem" target="_blank" rel="noopener">官方指引</a>,或者使用docker上的build-root镜像（<del>张口就来，其实我没实际用过</del>）。</p><p>代码更新完后更新一下软件包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;./scripts/feeds update -a</span><br><span class="line">&gt;./scripts/feeds install -a</span><br></pre></td></tr></table></figure><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>那么可以开始编译固件了</p><p>首先把最重要的FPU支持打开,先进入内核选项菜单:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make kernel_menuconfig</span><br></pre></td></tr></table></figure><p>按下列路径进去把FPU支持开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel type ---&gt; MIPS FPU Emulator</span><br></pre></td></tr></table></figure><p>然后再去把需要预装的包都勾上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make menuconfig</span><br></pre></td></tr></table></figure><p>我的小Y是MT7620的板，开启5G-wifi需要安装<code>kmod-mt76</code>,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel modules ---&gt; wireless drivers ---&gt; kmod-mt76</span><br></pre></td></tr></table></figure><p>再去把usb自动挂载配置好（未雨绸缪）:</p><blockquote><ol><li>添加USB相关支持<br>• Kernel modules —&gt; USB Support —&gt; &lt;<em>&gt; kmod-usb-core.   #默认已经选了<br>• Kernel modules —&gt; USB Support —&gt; &lt;</em>&gt; kmod-usb-ohci.   #默认已选 old usb1.0<br>• Kernel modules —&gt; USB Support —&gt; &lt;<em>&gt; kmod-usb-uhci.   # usb1.1<br>• Kernel modules —&gt; USB Support —&gt; &lt;</em>&gt; kmod-usb-storage.<br>• Kernel modules —&gt; USB Support —&gt; &lt;<em>&gt; kmod-usb-storage-extras.<br>• Kernel modules —&gt; USB Support —&gt; &lt;</em>&gt; kmod-usb2.   #默认已经选了 usb2.0<br>• 再加个usb3</li><li>添加USB挂载<br>• Base system —&gt; &lt;*&gt;block-mount</li><li>添加自动挂载工具<br>• Utilities —&gt; Filesystem —&gt; &lt;*&gt; badblocks</li><li>添加文件系统支持<br>• Kernel modules —&gt; Filesystems —&gt; &lt;<em>&gt; kmod-fs-ext4 (移动硬盘EXT4格式选择)<br>• Kernel modules —&gt; Filesystems —&gt; &lt;</em>&gt; kmod-fs-vfat(FAT16 / FAT32 格式 选择)</li><li>添加UTF8编码,CP437编码，ISO8859-1编码（否则即使/dev/中出现设备也无法挂载）<br>• Kernel modules —&gt; Native Language Support —&gt; &lt;<em>&gt; kmod-nls-utf8<br>• Utilities  —&gt; disc —&gt; &lt;</em>&gt; fdisk……………………………… manipulate disk partition table<br>• Utilities  —&gt; &lt;*&gt; usbutils…………………………….. USB devices listing utilities</li></ol></blockquote><p>又因为后面需要设置iptables转发，所以需要在menuconfig中安装如下包,因为是自编译固件，所以有些不能通过官方feed安装，提前放在这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip-tiny / ip-full</span><br><span class="line">ipset</span><br><span class="line">iptables</span><br><span class="line">iptables-mod-tproxy</span><br><span class="line">kmod-ipt-ipset</span><br><span class="line">kmod-ipt-tproxy</span><br><span class="line">libipset</span><br></pre></td></tr></table></figure><p>首先先把之前的toolchain等清理掉，因为占用的磁盘真的大。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make dirclean <span class="comment"># /bin /build_dir /staging_dir /toolchain /tmp /logs.</span></span><br></pre></td></tr></table></figure><p>建议第一遍编译先用verbose模式输出日志，<del>一遍成功是不存在的</del>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make -j1 V=s</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>编译过程中出现了这样的complain：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Image file /openwrt/cc/build_dir/target-mipsel_24kc_musl/linux-ramips_mt7620/tmp/openwrt-ramips-mt7620-ex2700-squashfs-sysupgrade.bin is too big</span><br></pre></td></tr></table></figure><p>这因为胡乱塞了很多东西，导致没办法兼容Flash只有4M的设备。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ./target/linux/ramips/image/Makefile</span><br></pre></td></tr></table></figure><p>修改220行的<code>ralink_default_fw_size_4M=3866624</code>值为更大的就好了。<br>而我的做法是：重进menuconfig，把忘记选上的profile选好，这样就只编译我需要的Y1固件了，XD</p><hr><p>漫无止境的编译和网络I/O…</p><h1 id="十年后"><a href="#十年后" class="headerlink" title="十年后"></a>十年后</h1><p>新鲜出炉的固件在<code>/bin</code>目录下，又回到最初的起点。</p><h2 id="编译V2ray"><a href="#编译V2ray" class="headerlink" title="编译V2ray"></a>编译V2ray</h2><p>根据<a href="https://www.v2ray.com/developer/intro/compile.html" target="_blank" rel="noopener">v2ray的官方指引</a>准备好编译环境。</p><p>分别编译v2ray和v2ctl：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/v2ray/core/main</span><br><span class="line">&gt; GOARCH=mipsle GOMIPS=softfloat go build -ldflags <span class="string">'-w -s'</span> -o v2ray</span><br><span class="line">&gt; <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/v2ray.com/ext/tools/control/main</span><br><span class="line">&gt; GOARCH=mipsle GOMIPS=softfloat go build -ldflags <span class="string">'-w -s'</span> -o v2ctl</span><br></pre></td></tr></table></figure><p>题外话，我发现v2ray自带的构建工具vbuild并没有考虑GOPATH变量中存在两个路径的情况：我的GOPATH中第一个路径设定为第三方lib的目录，接着的是个人项目的目录，这样在<code>go get</code>时会自动把依赖库都放在第一个目录中，这就把它们和个人项目分开来了。</p><h2 id="配置透明代理"><a href="#配置透明代理" class="headerlink" title="配置透明代理"></a>配置透明代理</h2><p>因为挂载了U盘，磁盘空间有余裕了，我打算先把透明代理配置好，先不用upx压缩。</p><p>我的iptables设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MY_VPS=xx.xx.xx.xx</span><br><span class="line">MY_PROXY_PORT=1060</span><br><span class="line">SKIP_IP=<span class="string">'0.0.0.0/8 10.0.0.0/8 127.0.0.0/8 169.254.0.0/16</span></span><br><span class="line"><span class="string">        172.16.0.0/12 192.168.0.0/16 224.0.0.0/4 240.0.0.0/4'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new chain</span></span><br><span class="line">iptables -t nat -N V2RAY</span><br><span class="line">iptables -t mangle -N V2RAY_MARK</span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp rule</span></span><br><span class="line">iptables -t nat -A V2RAY -d <span class="variable">$MY_VPS</span> -j RETURN   <span class="comment"># direct connect</span></span><br><span class="line">iptables -t nat -A V2RAY -p tcp -j RETURN -m mark --mark 0xff <span class="comment"># avoid loop</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$SKIP_IP</span>;<span class="keyword">do</span></span><br><span class="line">    iptables -t nat -A V2RAY -d <span class="variable">$IP</span> -j RETURN</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A V2RAY -p tcp -j REDIRECT --to-ports <span class="variable">$MY_PROXY_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># udp rule</span></span><br><span class="line">ip rule del fwmark 1</span><br><span class="line">ip rule add fwmark 1 table 100</span><br><span class="line">ip route add <span class="built_in">local</span> 0.0.0.0/0 dev lo table 100</span><br><span class="line">ip route flush cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$SKIP_IP</span>;<span class="keyword">do</span></span><br><span class="line">    iptables -t mangle -A V2RAY_MARK -d <span class="variable">$IP</span> -j RETURN</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">iptables -t mangle -A V2RAY_MARK -p udp -j TPROXY --on-port <span class="variable">$MY_PROXY_PORT</span> --tproxy-mark 0x01/0x01</span><br><span class="line"></span><br><span class="line"><span class="comment"># apply chain</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j V2RAY <span class="comment"># 对局域网其他设备进行透明代理</span></span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j V2RAY <span class="comment"># 对本机进行透明代理</span></span><br><span class="line"></span><br><span class="line">iptables -t mangle -A PREROUTING -p udp -j V2RAY_MARK</span><br></pre></td></tr></table></figure><p>我的v2ray设置，部分省略：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "inbound": &#123; ... &#125;,</span><br><span class="line">  "inboundDetour": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"dokodemo-door"</span>,</span><br><span class="line">      <span class="attr">"listen"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">      "port": 1060, // 转发到这里</span><br><span class="line">      "sniffing": &#123;</span><br><span class="line">        "enabled": true,</span><br><span class="line">        "destOverride": [</span><br><span class="line">          "http",</span><br><span class="line">          <span class="string">"tls"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      "settings": &#123;</span><br><span class="line">        "network": "tcp,udp",</span><br><span class="line">        "followRedirect": true,</span><br><span class="line">        "timeout": 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "outbound": &#123; ... &#125;,</span><br><span class="line">  "outboundDetour": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"sockopt"</span>: &#123;</span><br><span class="line">          <span class="attr">"mark"</span>: <span class="number">255</span> // MARK</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"block"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "routing": &#123;</span><br><span class="line">    "strategy": "rules",</span><br><span class="line">    "settings": &#123;</span><br><span class="line">      "domainStrategy": "AsIs",</span><br><span class="line">      "rules": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span>,</span><br><span class="line">          <span class="attr">"protocol"</span>: [</span><br><span class="line">            <span class="string">"bittorrent"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"domain"</span>: [</span><br><span class="line">            <span class="string">"geosite:cn"</span>,</span><br><span class="line">            <span class="string">"geosite:speedtest"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"ip"</span>: [</span><br><span class="line">            <span class="string">"geoip:cn"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成功彼岸"><a href="#成功彼岸" class="headerlink" title="成功彼岸"></a>成功彼岸</h2><p><strong>正式宣布爱国特区成立，papapapa！</strong><br>不过有点悲伤的是运行v2ray之后的5分钟载荷一直在1.5左右浮动，不过实际的网络响应速度还是能接受。<br>先写到这里，其它内容放到之后再整理。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://gobomb.github.io/post/cross-complie-v2ray/" target="_blank" rel="noopener">https://gobomb.github.io/post/cross-complie-v2ray/</a></li><li><a href="http://www.tldp.org/HOWTO/Adv-Routing-HOWTO/index.html" target="_blank" rel="noopener">http://www.tldp.org/HOWTO/Adv-Routing-HOWTO/index.html</a></li><li><a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/c/iptables.html</a></li><li><a href="https://toutyrater.github.io/app/transparent_proxy.html" target="_blank" rel="noopener">https://toutyrater.github.io/app/transparent_proxy.html</a></li><li><a href="https://wiki.openwrt.org/doc/howto/netfilter#configuration" target="_blank" rel="noopener">https://wiki.openwrt.org/doc/howto/netfilter#configuration</a></li><li><a href="https://wiki.openwrt.org/inbox/doc/iptables_and_firewall" target="_blank" rel="noopener">https://wiki.openwrt.org/inbox/doc/iptables_and_firewall</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个小目标&quot;&gt;&lt;a href=&quot;#一个小目标&quot; class=&quot;headerlink&quot; title=&quot;一个小目标&quot;&gt;&lt;/a&gt;一个小目标&lt;/h1&gt;&lt;p&gt;今天把我的小Y从&lt;em&gt;lede-17.01&lt;/em&gt;升级到了&lt;em&gt;openwrt-18.06.1&lt;/em&gt;。对，
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
      <category term="openwrt" scheme="https://joe-xu.github.io/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程内存耗用的表述：VSS/RSS/PSS/USS</title>
    <link href="https://joe-xu.github.io/2018/09/19/vss-rss-pss-uss/"/>
    <id>https://joe-xu.github.io/2018/09/19/vss-rss-pss-uss/</id>
    <published>2018-09-19T13:09:30.000Z</published>
    <updated>2018-09-19T15:34:55.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小白如我，写完程序想看看内存占用多少，打开了<code>top</code>却不知道看哪一项为准。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>一开始我也是很懵。</p><p>先一起看看它们的全称和释义：</p><blockquote><p>VSS(VSZ) - Virtual Set Size<br>The Virtual Set Size is a memory size assigned to a process ( program ) during the initial execution. The Virtual Set Size memory is simply a number of how much memory a process has available for its execution.</p></blockquote><p>VSS即由进程视角看到的所有可访问的内存大小，包括被置入交换区的部分，是由系统分配的虚拟内存。</p><blockquote><p>RSS - Resident Set Size<br>RSS is a memory currently used by a process. This is a actual number in kilobytes of how much RAM the current process is using.</p></blockquote><p>RSS则是进程在内存中实际占有的物理内存大小，正如其名是常驻集大小，所以不包括被置换进交换区的部分。</p><blockquote><p>PSS - Proportional Set Size<br>Pss is the amount of memory shared with other processes, accounted in a way that the amount is divided evenly between the processes that share it. This is memory that would not be released if the process was terminated, but is indicative of the amount that this process is “contributing”.</p></blockquote><p>由于不同进程间会在内存中共同享有一些内存，如共享库，所以PSS可以综合考虑共享进程数，将共享库的内存占用按比例算入到进程名下。</p><blockquote><p>USS - Unique Set Size<br>Uss is the set of pages that are unique to a process. This is the amount of memory that would be freed if the application was terminated right now.</p></blockquote><p>USS则是进程单独占用的内存，如堆和栈都是不能给别人看的。</p><blockquote><p>The unshared memory (USS) plus a process’s proportion of shared memory is reported as the PSS (Proportional Set Size). The USS and PSS only include physical memory usage. They do not include memory that has been swapped out to disk.</p></blockquote><p>又根据上面<code>smem(8)</code>的描述可知，USS和PSS都不包含被置入交换区的部分。</p><p>所以一般来说有<code>VSS &gt;= RSS &gt;= PSS &gt;= USS</code>。</p><h2 id="一个计算例子"><a href="#一个计算例子" class="headerlink" title="一个计算例子"></a>一个计算例子</h2><p>假设有进程A，程序大小500K，链接共享库大小2500K，现在进程实际加载了共享库的1000K以及自身程序的400K，且堆栈大小200K，其中的100K被置入交换区，那么有：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VSS = 500K + 2500K + 200K = 3200K</span><br><span class="line">RSS = 400K + 1000K + 100K = 1500K</span><br><span class="line">PSS = 400K + 1000K/2 + 100K = 1000K <span class="comment"># 假设两个进程使用共享库</span></span><br><span class="line">USS = 400K + 100K = 500K</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>因为VSS还统计了进程尚未在内存中使用的大小（如进程<code>malloc</code>后，系统并不会第一时间分配内存）所以一般不用来衡量进程的内存占用；</li><li>而RSS因为将进程使用的共享库纳入统计，即使这个库能被复数进程共享，所以单独使用RSS作为测量项也会有误导性；</li><li>相对于RSS，PSS更适合作为进程内存占用的衡量项，而且<a href="https://unix.stackexchange.com/questions/34189/how-often-is-pss-value-updated-for-a-given-process-in-proc-pid-smaps" target="_blank" rel="noopener">不用担心PSS的更新时间</a>;</li><li>USS则非常适合用来采样观察进程是否发生了内存泄漏。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://linuxconfig.org/ps-output-difference-between-vsz-vs-rss-memory-usage" target="_blank" rel="noopener">https://linuxconfig.org/ps-output-difference-between-vsz-vs-rss-memory-usage</a></li><li><a href="https://elinux.org/Android_Memory_Usage" target="_blank" rel="noopener">https://elinux.org/Android_Memory_Usage</a></li><li><a href="https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management" target="_blank" rel="noopener">https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management</a></li><li><a href="https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate" target="_blank" rel="noopener">https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate</a></li><li><a href="https://www.jianshu.com/p/9bf36aa82f90" target="_blank" rel="noopener">https://www.jianshu.com/p/9bf36aa82f90</a></li><li><a href="https://linux.die.net/man/8/smem" target="_blank" rel="noopener">https://linux.die.net/man/8/smem</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;小白如我，写完程序想看看内存占用多少，打开了&lt;code&gt;top&lt;/code&gt;却不知道看哪一项为准。&lt;/p&gt;
&lt;h2 id=&quot;是什么？&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#4</title>
    <link href="https://joe-xu.github.io/2018/09/12/reading-the-go-programming-language-04/"/>
    <id>https://joe-xu.github.io/2018/09/12/reading-the-go-programming-language-04/</id>
    <published>2018-09-12T12:36:41.000Z</published>
    <updated>2018-09-24T13:26:00.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h2><h3 id="lt-P120-gt"><a href="#lt-P120-gt" class="headerlink" title="&lt; P120 &gt;"></a>&lt; P120 &gt;</h3><ul><li><p>函数传参都是值传递；在传递<code>slice</code>时，会复制一个<code>slice</code>的<code>struct</code>，包含了底层数组指针、<code>len</code>、<code>cap</code>，虽然被调用函数可以改变底层数组，但是其中<code>len</code>，<code>cap</code>等对调用者是不可见的，除非用指针或返回新值更新；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(val []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val = <span class="built_in">append</span>(val, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(val []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    val = <span class="built_in">append</span>(val, <span class="number">321</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(val))</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    f1(val)</span><br><span class="line">    val = f2(val)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> val &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\t%d\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  1</span></span><br><span class="line"><span class="comment">//  0   321</span></span><br></pre></td></tr></table></figure></li><li><p>函数的类型又称作函数签名（signature），参数以及返回值的变量名对签名无影响；</p></li><li>Go的栈是可变的，取决于内存大小， 可以增长到数G；</li></ul><h3 id="lt-P125-gt"><a href="#lt-P125-gt" class="headerlink" title="&lt; P125 &gt;"></a>&lt; P125 &gt;</h3><ul><li>go的GC不会回收操作系统资源，如打开的文件、网络连接等，必须进行显式的回收；</li><li>当所有返回值都是具名的，return的操作数可以忽略，称作裸返回（bare return）；</li></ul><h3 id="lt-P134-gt"><a href="#lt-P134-gt" class="headerlink" title="&lt; P134 &gt;"></a>&lt; P134 &gt;</h3><ul><li>函数可以赋值，即函数可以作为参数传递；</li><li><p><code>%*s</code>中的<code>*</code>修饰符可以指定字符串前有多少空格；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%*s"</span>, <span class="number">5</span> , <span class="string">"text"</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="lt-P135-gt"><a href="#lt-P135-gt" class="headerlink" title="&lt; P135 &gt;"></a>&lt; P135 &gt;</h3><p>具名函数只能在包级定义；但是匿名函数可以在函数内部给函数变量赋值；但是如果需要递归调用，用<code>:=</code>定义函数变量会导致不能调用自身,可以尝试下面这种方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visitAll <span class="function"><span class="keyword">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">visitAll</span> = <span class="title">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">if</span> !seen[item] &#123;</span><br><span class="line">            seen[item] = <span class="literal">true</span></span><br><span class="line">            visitAll(m[item])</span><br><span class="line">            order = <span class="built_in">append</span>(order, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-P141-gt"><a href="#lt-P141-gt" class="headerlink" title="&lt; P141 &gt;"></a>&lt; P141 &gt;</h3><p>注意在使用闭包时捕获迭代局部变量的问题，应该用一个新的局部变量保存；</p><h3 id="lt-P144-gt"><a href="#lt-P144-gt" class="headerlink" title="&lt; P144 &gt;"></a>&lt; P144 &gt;</h3><ul><li>在运行到<code>defer</code>语句时，<em>deferred</em>的函数参数值就确定了，只有函数的执行被延迟；</li><li><em>Deferred</em>的函数在<code>return</code>之后执行；</li></ul><h3 id="lt-P151-gt"><a href="#lt-P151-gt" class="headerlink" title="&lt; P151 &gt;"></a>&lt; P151 &gt;</h3><p><em>Deferred</em>的函数调用的<code>runtime.Stack</code>方法可以打印<code>panic</code>时的<code>stack</code>是因为Go的<code>panic</code>机制会先运行<em>deferred function</em>再<em>unwind the stack</em>；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第五章-函数&quot;&gt;&lt;a href=&quot;#第五章-函数&quot; class=&quot;headerlink&quot; title=&quot;第五章 函数&quot;&gt;&lt;/a&gt;第五章 函数&lt;/h2&gt;&lt;h3 id=&quot;lt-P120-gt&quot;&gt;&lt;a href=&quot;#lt-P120-gt&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#3</title>
    <link href="https://joe-xu.github.io/2018/09/10/reading-the-go-programming-language-03/"/>
    <id>https://joe-xu.github.io/2018/09/10/reading-the-go-programming-language-03/</id>
    <published>2018-09-10T12:41:01.000Z</published>
    <updated>2018-09-24T13:17:53.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h2><h3 id="lt-P83-gt"><a href="#lt-P83-gt" class="headerlink" title="&lt; P83 &gt;"></a>&lt; P83 &gt;</h3><ul><li>长度亦算数组类型的一部分因此两个长度不同的数组是不同类型；</li><li>只有两个数组的元素类型可以比较时，这两个数组才可以比较；</li><li>调用函数传值时，会将数组拷贝传递（传值引用），所以在函数内的修改对原数组无影响；</li></ul><h3 id="lt-P86-gt"><a href="#lt-P86-gt" class="headerlink" title="&lt; P86 &gt;"></a>&lt; P86 &gt;</h3><ul><li>数组和切片声明时可以显式声明<em>index</em>，当两者混用时，隐式声明的元素<em>index</em>随前方相邻的显式声明<em>index</em>自增；</li><li><p>与数组不同，切片不能直接用<code>==</code>或<code>!=</code>比较，只有与<code>nil</code>的比较是合法的，除了<code>[]byte</code>可以用<code>bytes.Equal</code>方法比较外，其它类型切片我们都要自行逐个元素比较；</p><blockquote><p><a href="http://blog.csdn.net/erlib/article/details/50957218" target="_blank" rel="noopener">Go语言核心之美 3.2－slice切片</a><br>为什么Go语言不支持<code>slice</code>的比较运算呢？</p><ul><li>第一个原因，<code>slice</code>是引用类型，一个<code>slice</code>甚至可以引用自身。虽然有很多解决办法，但是没有一个是简单有效的;</li><li>第二个原因，因为<code>slice</code>是间接引用，因此一个<code>slice</code>在不同时间可能包含不同的元素－底层数组的元素可能被修改;</li><li>只要一个数据类型可以做相等比较，那么就可以用来做<code>map</code>的<em>key</em>,<code>map</code>这种数据结构对<em>key</em>的要求是：如果最开始时<em>key</em>是相等的，那在<code>map</code>的生命周期内，<em>key</em>要一直相等，因此这里<em>key</em>是不可变的。而对于指针或<code>chan</code>这类引用类型，<code>==</code>可以判断两个指针是否引用了想同的对象，是有用的，但是<code>slice</code>的相等测试充满了不确定性，因此，安全的做法是禁止<code>slice</code>之间的比较操作。</li></ul></blockquote></li><li><p>可以存在<code>len</code>和<code>cap</code>都为<code>0</code>但是<em>non-nil</em>的<code>slice</code>，所以判定<code>slice</code>是否为空应该用<code>len</code>;</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="lt-P94-gt"><a href="#lt-P94-gt" class="headerlink" title="&lt; P94 &gt;"></a>&lt; P94 &gt;</h3><ul><li><code>map</code>的键应该可以用<code>==</code>比较，不建议用浮点数作键；</li><li><p><code>map</code>中的元素不是变量，因此不能被取地址；</p><blockquote><p><code>map</code>可能会随着元素的增多重新分配更大的内存空间，旧值都会拷贝到新的内存空间，因此之前的地址就会失效。</p></blockquote></li><li><p>和切片一样，<code>map</code>间不能直接比较，只有和<code>nil</code>比较是合法的；</p></li></ul><h3 id="lt-P100-gt"><a href="#lt-P100-gt" class="headerlink" title="&lt; P100 &gt;"></a>&lt; P100 &gt;</h3><p>结构体的字段（field）可以取地址并通过指针访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Employee</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(EmployeeByID(dilbert.ManagerID).Position)   <span class="comment">// "Pointy-haired boss"</span></span><br><span class="line"></span><br><span class="line">id := dilbert.ID</span><br><span class="line">EmployeeByID(id).Salary = <span class="number">0</span> <span class="comment">// fired for... no real reason</span></span><br></pre></td></tr></table></figure><p>最后那条语句需要注意，它调用<code>EmployeeByID</code>生成了一个<code>*Employee</code>指针，然后直接更新该结构体中的一个字段。如果将<code>EmployeeByID</code>的返回值从<code>*Employee</code>换成<code>Employee</code>类型，那么编译将报错，因为编译器无法对返回的<code>Employee</code>进行寻址(<strong>不通过变量直接使用一个值，一般都无法进行寻址</strong>)。</p><h3 id="lt-P101-gt"><a href="#lt-P101-gt" class="headerlink" title="&lt; P101 &gt;"></a>&lt; P101 &gt;</h3><p><strong>对于结构体来说，字段顺序很重要，如果顺序不同或者有一些字段合并声明，即使字段名完全相同，那也算两个完全不同的结构体类型;</strong></p><h3 id="lt-P104-gt"><a href="#lt-P104-gt" class="headerlink" title="&lt; P104 &gt;"></a>&lt; P104 &gt;</h3><p>当结构体中所有字段都可以比较时，这个结构体类型才可以相比较；</p><h3 id="lt-P106-gt"><a href="#lt-P106-gt" class="headerlink" title="&lt; P106 &gt;"></a>&lt; P106 &gt;</h3><ul><li><p>准确来说，结构体中的匿名字段并不是真正的匿名，有隐式的与类型名相同的名字；在格式化字符串中加入<code>#</code>，<code>#</code>代表用Go的语法来打印。对于<code>struct</code>类型来说，打印中将包含每个字段的信息；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;   <span class="comment">//  or   w = Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>当匿名字段没有导出时，不能用长赋值形式；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  mStruct.go</span></span><br><span class="line"><span class="keyword">package</span> mStruct</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cyc <span class="keyword">struct</span> &#123;</span><br><span class="line">    point</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m = mStruct.Cyc&#123;&#125;</span><br><span class="line">    m.X = <span class="number">1</span></span><br><span class="line">    m.point.Y = <span class="number">2</span>   <span class="comment">//  cannot refer to unexported field or method point</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, m)  <span class="comment">//  mStruct.Cyc&#123;point:mStruct.point&#123;X:1, Y:0&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第四章-复合类型&quot;&gt;&lt;a href=&quot;#第四章-复合类型&quot; class=&quot;headerlink&quot; title=&quot;第四章 复合类型&quot;&gt;&lt;/a&gt;第四章 复合类型&lt;/h2&gt;&lt;h3 id=&quot;lt-P83-gt&quot;&gt;&lt;a href=&quot;#lt-P83-gt&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#2</title>
    <link href="https://joe-xu.github.io/2018/09/07/reading-the-go-programming-language-02/"/>
    <id>https://joe-xu.github.io/2018/09/07/reading-the-go-programming-language-02/</id>
    <published>2018-09-07T12:10:47.000Z</published>
    <updated>2018-09-24T13:56:56.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-基本数据类型"><a href="#第三章-基本数据类型" class="headerlink" title="第三章 基本数据类型"></a>第三章 基本数据类型</h2><p>主要围绕基本类型来讲的一章，仍记得当时看的时候按捺不住想要跳过的心，但是第三章还是非常重要的，有详细讲解最常用的<code>slice</code>内存模型避免误用，而且还穿插了一些有趣的小例程，譬如教你怎么画一个漂亮的分型图等。</p><p>但是这里我只post自己整理的笔记。XD</p><a id="more"></a><h3 id="lt-P52-gt"><a href="#lt-P52-gt" class="headerlink" title="&lt; P52 &gt;"></a>&lt; P52 &gt;</h3><ul><li><code>int</code>与<code>uint</code>的字节长度在不同实现的编译器下可能不同，即使是在同一个主机上；</li><li><code>%</code>仅能用于整型；</li><li>在Go中，余数符号永远与被除数相同，即<code>-5%3</code>与<code>-5%-3</code>同样得<code>-2</code>；</li></ul><h3 id="lt-P57-gt"><a href="#lt-P57-gt" class="headerlink" title="&lt; P57 &gt;"></a>&lt; P57 &gt;</h3><ul><li><p><code>float</code>类型变量为0时作被除数为<em>可疑运算（dubious operation）</em>，若用整型在编译时会报错，可以表示正负无穷以及<code>NaN</code>（not a number）；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float32</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z)  <span class="comment">// 0 -0 +Inf -Inf NaN</span></span><br></pre></td></tr></table></figure></li><li><p><code>math.NaN</code>函数也可以返回<code>NaN</code>，并且<code>NaN</code>的任何比较结果都是<code>false</code>，可以使用<code>math.IsNaN</code>函数判定；</p></li></ul><h3 id="lt-P63-gt"><a href="#lt-P63-gt" class="headerlink" title="&lt; P63 &gt;"></a>&lt; P63 &gt;</h3><ul><li>如果<code>s</code>是空字符串，使用<code>s[0</code>]会引起<code>panic</code>；</li><li>不存在<code>0</code>或<code>1</code>等到布尔类型的隐式转换，反过来同理；</li></ul><h3 id="lt-P65-gt"><a href="#lt-P65-gt" class="headerlink" title="&lt; P65 &gt;"></a>&lt; P65 &gt;</h3><ul><li>字符串的值是不可更改的，所以字符串拷贝和子字符串都可以与原串共用同一空间，操作廉价，但是<code>string</code>类型变量可以重新赋值；</li><li>内建函数<code>len</code>返回的是字符串的<code>byte</code>数，要在utf-8格式下计数可以用<code>utf8.RuneCountInString</code>方法；</li></ul><h3 id="lt-P70-gt"><a href="#lt-P70-gt" class="headerlink" title="&lt; P70 &gt;"></a>&lt; P70 &gt;</h3><ul><li><strong>使用<code>range</code>遍历字符串时，会隐式对utf8解码，索引<code>i</code>也会跳动</strong>；</li><li>每当utf8解码器遇到一个非预期的<code>byte</code>，不管是显式的调用<code>utf8.DecodeRuneInString</code>方法还是在<code>range</code>中隐式调用，会产生一个<em>replacement character</em>（\uFFFD），就是常见的黑底六角形加上白色问号的符号；</li></ul><h3 id="lt-P78-gt"><a href="#lt-P78-gt" class="headerlink" title="&lt; P78 &gt;"></a>&lt; P78 &gt;</h3><ul><li>经编译器处理，无类型常量的精度比基本类型更大，且四则运算同样，大约有256 bit的精度；</li><li>只有常量是无类型的，当常量被赋值给一个特定类型变量时会被隐式转换；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-基本数据类型&quot;&gt;&lt;a href=&quot;#第三章-基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本数据类型&quot;&gt;&lt;/a&gt;第三章 基本数据类型&lt;/h2&gt;&lt;p&gt;主要围绕基本类型来讲的一章，仍记得当时看的时候按捺不住想要跳过的心，但是第三章还是非常重要的，有详细讲解最常用的&lt;code&gt;slice&lt;/code&gt;内存模型避免误用，而且还穿插了一些有趣的小例程，譬如教你怎么画一个漂亮的分型图等。&lt;/p&gt;
&lt;p&gt;但是这里我只post自己整理的笔记。XD&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>说说login shell和non-login shell</title>
    <link href="https://joe-xu.github.io/2018/09/06/login-shell-and-non-login-shell/"/>
    <id>https://joe-xu.github.io/2018/09/06/login-shell-and-non-login-shell/</id>
    <published>2018-09-06T12:46:39.000Z</published>
    <updated>2018-09-19T13:10:28.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近又要在公司的CentOS上配一遍开发环境，这就避不了要编辑一番<code>PATH</code>，那么问题来了，这是要写在<code>/etc/profile</code>、<code>~/.profile</code>、<code>~/.bash_profile</code>还是<code>~/.bashrc</code>或<code>~/.bash_login</code>呢?首先，可以排除影响全局的<code>/etc/profile</code>，这改了听起来就是给后来的自己挖坑(还有一个<code>/etc/bash.bashrc</code>)。接着我们就要厘清后四个的区别了，这就要从<em>login shell</em>和<em>non-login shell</em>的区别说起。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不用Google，有事先找<code>man</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; man bash</span><br></pre></td></tr></table></figure><p>我们在<code>bash</code>的手册中<em>INVOCATION</em>一节就可以找到<em>login shell</em>的定义：</p><blockquote><p>A login shell is one whose first character of argument zero is a <code>-</code>, or one started with the <code>--login</code> option.</p></blockquote><p>顺便还有<em>interactive shell</em>的定义：</p><blockquote><p>An interactive shell is one started without non-option arguments and without the <code>-c</code> option whose standard input and error are both connected to terminals (as determined by  isatty(3)),  or one started with the <code>-i</code> option.</p></blockquote><p>可知有：</p><ul><li><em>交互式的 login shell</em>：本地登录、ssh登录、<code>bash --login</code>、<code>su - &lt;user&gt;</code>;</li><li><em>交互式的 non-login shell</em>：<code>su &lt;user&gt;</code>;</li><li><em>非交互的 non-login shell</em>：<code>ssh example.com my-script-which-is-on-the-remote-machine</code>;</li><li><em>非交互的 login shell</em>：脚本中使用<code>--login</code>(如<code>#!/bin/bash --login</code>);</li></ul><p>上述的情况并没有列全，可以通过如下方法区分login和non-login shell：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">-bash <span class="comment">#第一个字符是 "-"， 所以是 login shell。</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">bash <span class="comment">#不是一个login shell。</span></span><br></pre></td></tr></table></figure><h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>当一个<code>bash</code>是以<strong>交互式的login shell</strong>被调用时，它首先会读取<code>/etc/profile</code>文件，然后按照<code>~/.bash_profile</code>，<code>~/.bash_login</code>和<code>~/.profile</code>的顺序依次查找并读取，但这是短路式的，按顺序成功读取了三者之一就不继续往后查找了。最后在退出时会执行<code>~/.bash_logout</code>中的命令。</p><p>而<strong>交互式的non-login shell</strong>则先后读取<code>/etc/bash.bashrc</code>和<code>~/.bashrc</code>。</p><p><strong>非交互的non-login shell</strong>只展开环境变量<code>BASH_ENV</code>并执行其指向的文件。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>如果需要统一交互式的<em>login shell</em>和<em>non-login shell</em>环境，我们可以在<code>~/.bashrc</code>中编写配置，然后在<code>~/.bash_profile</code>读取<code>~/.bashrc</code>。非交互式的情况一般与脚本有关，一般是主动载入环境变量(因为环境变量问题，dockerfile中也建议使用绝对路径)，所以暂且不管。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://blog.sciencenet.cn/blog-3238131-1037461.html" target="_blank" rel="noopener">login shell与non-login shell的区别</a></li><li><a href="https://unix.stackexchange.com/questions/38175/difference-between-login-shell-and-non-login-shell" target="_blank" rel="noopener">difference-between-login-shell-and-non-login-shell</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近又要在公司的CentOS上配一遍开发环境，这就避不了要编辑一番&lt;code&gt;PATH&lt;/code&gt;，那么问题来了，这是要写在&lt;code&gt;/etc/profile&lt;/code&gt;、&lt;code&gt;~/.profile&lt;/code&gt;、&lt;code&gt;~/.bash_profile&lt;/code&gt;还是&lt;code&gt;~/.bashrc&lt;/code&gt;或&lt;code&gt;~/.bash_login&lt;/code&gt;呢?首先，可以排除影响全局的&lt;code&gt;/etc/profile&lt;/code&gt;，这改了听起来就是给后来的自己挖坑(还有一个&lt;code&gt;/etc/bash.bashrc&lt;/code&gt;)。接着我们就要厘清后四个的区别了，这就要从&lt;em&gt;login shell&lt;/em&gt;和&lt;em&gt;non-login shell&lt;/em&gt;的区别说起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://joe-xu.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#1</title>
    <link href="https://joe-xu.github.io/2018/09/05/reading-the-go-programming-language-01/"/>
    <id>https://joe-xu.github.io/2018/09/05/reading-the-go-programming-language-01/</id>
    <published>2018-09-05T13:04:40.000Z</published>
    <updated>2018-09-24T13:57:41.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-程序结构"><a href="#第二章-程序结构" class="headerlink" title="第二章 程序结构"></a>第二章 程序结构</h2><h3 id="lt-P28-gt"><a href="#lt-P28-gt" class="headerlink" title="&lt; P28 &gt;"></a>&lt; P28 &gt;</h3><p>Go中的<a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">Predeclared identifiers</a>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Types:</span><br><span class="line">bool byte complex64 complex128 error float32 float64</span><br><span class="line">int int8 int16 int32 int64 rune string</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">Constants:</span><br><span class="line">true false iota</span><br><span class="line"></span><br><span class="line">Zero value:</span><br><span class="line">nil</span><br><span class="line"></span><br><span class="line">Functions:</span><br><span class="line">append cap close complex copy delete imag len</span><br><span class="line">make new panic print println real recover</span><br></pre></td></tr></table></figure><p>这里面的关键字都是不保留的，可以用作我们的自定变量名，当然这是强烈不推荐的。<del>除非已经被<em>命名困难症</em>逼到了绝境。</del></p><p>另外，变量名长度是不作限定的（the larger the scope of a name, the longer and more meanningful it should be），一个全局变量的名字应该比一个局部变量更易见名知义（所以长点也没关系）。</p><h3 id="lt-P31-gt"><a href="#lt-P31-gt" class="headerlink" title="&lt; P31 &gt;"></a>&lt; P31 &gt;</h3><ul><li><code>:=</code>(the short variable declaration)是用作声明的，而不是像<code>=</code>一样用作赋值；</li><li><code>:=</code>左边至少要存在一个未声明的变量；</li></ul><h3 id="lt-P35-gt"><a href="#lt-P35-gt" class="headerlink" title="&lt; P35 &gt;"></a>&lt; P35 &gt;</h3><p>如果两个变量的类型不承载任何信息，根据编译器的实现，指针地址可能相同，例如<code>struct{}</code>和<code>[0]int</code>；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> t2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, &amp;t1 == &amp;t2)   <span class="comment">//true  t1,t2为[0]int时同理</span></span><br></pre></td></tr></table></figure><h3 id="lt-P36-gt"><a href="#lt-P36-gt" class="headerlink" title="&lt; P36 &gt;"></a>&lt; P36 &gt;</h3><ul><li>用生命周期长的指针指向生命周期短的变量会阻碍对该变量的GC；</li><li><strong>变量被分配到堆或栈与否不由声明方式决定</strong>，如<code>var</code>或<code>new</code>；(mark一下，之后再拓展一篇，<del>如果还有机会看见这个mark</del>)</li></ul><h3 id="lt-P39-gt"><a href="#lt-P39-gt" class="headerlink" title="&lt; P39 &gt;"></a>&lt; P39 &gt;</h3><p>显式类型转换<code>T(x)</code>是一种<a href="https://golang.org/ref/spec#Conversions" target="_blank" rel="noopener">转换(conversion)</a>，不是函数调用；</p><h3 id="lt-P41-gt"><a href="#lt-P41-gt" class="headerlink" title="&lt; P41 &gt;"></a>&lt; P41 &gt;</h3><p>首先看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> x T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会隐式调用T的String方法（如果有）</span></span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>,x)</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>,x)</span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会调用</span></span><br><span class="line">fmt.Printf(<span class="string">"%g"</span>,x)</span><br><span class="line">fmt.Println(<span class="keyword">float64</span>(x))</span><br></pre></td></tr></table></figure><p>那么我们在给<code>T</code>实现<code>String()</code>且需要打印自身时，要注意避免无穷递归调用。</p><h3 id="lt-P46-gt"><a href="#lt-P46-gt" class="headerlink" title="&lt; P46 &gt;"></a>&lt; P46 &gt;</h3><ul><li>变量的作用域与生命周期不相等，作用域是编译时属性(compile-time property)，而生命周期是运行时属性(run-time porperty)；</li><li><p>有或没有显式地用花括号界定的作用域都可以笼统地归纳为<em>lexical block</em>；例如包含整个源码的<em>universe <a href="https://golang.org/ref/spec#Blocks" target="_blank" rel="noopener">block</a></em>，每个<code>package</code>、文件、<code>for</code>、<code>if</code>、<code>switch/select</code>，<code>switch/select</code>中的每个<code>case</code>；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">x := <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">for</span>  _ , x := <span class="keyword">range</span> x&#123;  <span class="comment">// for statement中有隐式lexical block</span></span><br><span class="line">x := x +<span class="string">'A'</span>-<span class="string">'a'</span>     <span class="comment">// &#123;&#125;中的显式lexical block</span></span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>,x)  <span class="comment">// 正常输出"HELLO"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导入的包的作用域是<em>file-level</em>的，所以每个文件都要单独导入，即使是同一个包下；</p></li><li><em>Control-flow label</em>（用于<code>break</code>、<code>continue</code>和<code>goto</code>）的作用域是整个函数；</li><li>编译器会从最内的<em>lexical block</em>至<em>universe block</em>查找变量的声明；所以最内部变量可以<em>shadow</em>（又或称屏蔽/<em>hide</em>）外部同名变量；</li></ul><h3 id="lt-P49-gt"><a href="#lt-P49-gt" class="headerlink" title="&lt; P49 &gt;"></a>&lt; P49 &gt;</h3><p><strong>在使用<code>:=</code>时要注意作用域</strong>；例如，如果要在函数内更新<em>package-level</em>变量，使用<code>:=</code>会重新声明一个同名局部变量；</p><h2 id="一段闲扯"><a href="#一段闲扯" class="headerlink" title="一段闲扯"></a>一段闲扯</h2><blockquote><p>！！距离拖延症发作过去了<strong>03</strong>天！！</p></blockquote><p>从第二章开始的内容已经比第一章多了，不过想想，这也是肯定的。按照这个劲头，似乎半个月就能把这个系列整理完。另外hexo是真的好用，都要治好我多年的拖延症了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二章-程序结构&quot;&gt;&lt;a href=&quot;#第二章-程序结构&quot; class=&quot;headerlink&quot; title=&quot;第二章 程序结构&quot;&gt;&lt;/a&gt;第二章 程序结构&lt;/h2&gt;&lt;h3 id=&quot;lt-P28-gt&quot;&gt;&lt;a href=&quot;#lt-P28-gt&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#0</title>
    <link href="https://joe-xu.github.io/2018/09/04/reading-the-go-programming-language/"/>
    <id>https://joe-xu.github.io/2018/09/04/reading-the-go-programming-language/</id>
    <published>2018-09-04T12:41:44.000Z</published>
    <updated>2018-09-05T13:19:27.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>当初入坑Go的时候，怀着朝圣的心买了这本书(<a href="https://book.douban.com/subject/26859123/" target="_blank" rel="noopener">《Go程序设计语言》</a>)来啃。本以为我这样的拖延症会拖到最后而不了了之，没想到硬是被我啃完了，因为书中的内容确实引人入胜，除了深入浅出讲解Go外，还有许多扩展开来的相关知识和编程思想。</p><a id="more"></a><p>在啃书途中，也用Onenote整理的不少的笔记，主要是一些关键知识的摘抄，打算在懒癌没发作的时间整理成一系列blog，希望能在年末前更新完十三章，届时可能能作为我18年的最自豪成绩。</p><p>日后如果温故而知新了，会继续追加更新。</p><p><del>要说为什么我当时用Onenote，因为年轻的我还是忠实的田牌教徒，用着田牌手机还要四处张扬那种。</del></p><h2 id="第一章-综述"><a href="#第一章-综述" class="headerlink" title="第一章 综述"></a>第一章 综述</h2><h3 id="lt-P6-gt"><a href="#lt-P6-gt" class="headerlink" title="&lt; P6 &gt;"></a>&lt; P6 &gt;</h3><p>Go中有statement与expression的区分</p><blockquote><p><a href="https://golang.org/ref/spec#Expressions" target="_blank" rel="noopener">Go Spec#Expressions</a>：<br>An expression specifies the computation of a value by applying operators and functions to operands.</p></blockquote><blockquote><p><a href="https://golang.org/ref/spec#Statements" target="_blank" rel="noopener">Go Spec#Statements</a>：<br>Statements control execution.</p></blockquote><p>那么，值得注意的是<code>i++</code>在go中是<code>statement</code>，不同于其它C-like语言。这就是<code>j = i++</code>等类似语句非法的原因。</p><h3 id="lt-P7-gt"><a href="#lt-P7-gt" class="headerlink" title="&lt; P7 &gt;"></a>&lt; P7 &gt;</h3><ul><li>用<code>+=</code>进行字符串拼接时会申请内存创建新的字符串，要注意频繁的操作会引起更密集的GC；</li></ul><h3 id="lt-P9-gt"><a href="#lt-P9-gt" class="headerlink" title="&lt; P9 &gt;"></a>&lt; P9 &gt;</h3><ul><li><code>map</code>是对<code>make()</code>创建的数据结构的引用；</li><li><code>map</code>里的键可以实任意可以使用<code>==</code>作比较的类型，而存储的值可以实任意类型；<blockquote><p><a href="https://golang.org/ref/spec#Comparison_operators" target="_blank" rel="noopener">扩展阅读：Go的Comparable rules</a></p></blockquote></li><li><code>map</code>是无序的，值得注意的是，<code>map</code>在使用<code>range</code>进行遍历的访问顺序亦是随机的，这应该算Go中最应该注意的坑之一了，据说这是在设计Go的时候有意为之的（<em>It’s not a bug, it’s a feature!</em>）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;当初入坑Go的时候，怀着朝圣的心买了这本书(&lt;a href=&quot;https://book.douban.com/subject/26859123/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Go程序设计语言》&lt;/a&gt;)来啃。本以为我这样的拖延症会拖到最后而不了了之，没想到硬是被我啃完了，因为书中的内容确实引人入胜，除了深入浅出讲解Go外，还有许多扩展开来的相关知识和编程思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://joe-xu.github.io/2018/09/03/hello-world/"/>
    <id>https://joe-xu.github.io/2018/09/03/hello-world/</id>
    <published>2018-09-03T12:33:02.164Z</published>
    <updated>2018-09-03T12:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
