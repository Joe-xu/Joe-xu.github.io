<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinking_Out_Loud</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joe-xu.github.io/"/>
  <updated>2018-09-19T15:34:55.317Z</updated>
  <id>https://joe-xu.github.io/</id>
  
  <author>
    <name>Joe Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux进程内存耗用的表述：VSS/RSS/PSS/USS</title>
    <link href="https://joe-xu.github.io/2018/09/19/vss-rss-pss-uss/"/>
    <id>https://joe-xu.github.io/2018/09/19/vss-rss-pss-uss/</id>
    <published>2018-09-19T13:09:30.000Z</published>
    <updated>2018-09-19T15:34:55.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小白如我，写完程序想看看内存占用多少，打开了<code>top</code>却不知道看哪一项为准。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>一开始我也是很懵。</p><p>先一起看看它们的全称和释义：</p><blockquote><p>VSS(VSZ) - Virtual Set Size<br>The Virtual Set Size is a memory size assigned to a process ( program ) during the initial execution. The Virtual Set Size memory is simply a number of how much memory a process has available for its execution.</p></blockquote><p>VSS即由进程视角看到的所有可访问的内存大小，包括被置入交换区的部分，是由系统分配的虚拟内存。</p><blockquote><p>RSS - Resident Set Size<br>RSS is a memory currently used by a process. This is a actual number in kilobytes of how much RAM the current process is using.</p></blockquote><p>RSS则是进程在内存中实际占有的物理内存大小，正如其名是常驻集大小，所以不包括被置换进交换区的部分。</p><blockquote><p>PSS - Proportional Set Size<br>Pss is the amount of memory shared with other processes, accounted in a way that the amount is divided evenly between the processes that share it. This is memory that would not be released if the process was terminated, but is indicative of the amount that this process is “contributing”.</p></blockquote><p>由于不同进程间会在内存中共同享有一些内存，如共享库，所以PSS可以综合考虑共享进程数，将共享库的内存占用按比例算入到进程名下。</p><blockquote><p>USS - Unique Set Size<br>Uss is the set of pages that are unique to a process. This is the amount of memory that would be freed if the application was terminated right now.</p></blockquote><p>USS则是进程单独占用的内存，如堆和栈都是不能给别人看的。</p><blockquote><p>The unshared memory (USS) plus a process’s proportion of shared memory is reported as the PSS (Proportional Set Size). The USS and PSS only include physical memory usage. They do not include memory that has been swapped out to disk.</p></blockquote><p>又根据上面<code>smem(8)</code>的描述可知，USS和PSS都不包含被置入交换区的部分。</p><p>所以一般来说有<code>VSS &gt;= RSS &gt;= PSS &gt;= USS</code>。</p><h2 id="一个计算例子"><a href="#一个计算例子" class="headerlink" title="一个计算例子"></a>一个计算例子</h2><p>假设有进程A，程序大小500K，链接共享库大小2500K，现在进程实际加载了共享库的1000K以及自身程序的400K，且堆栈大小200K，其中的100K被置入交换区，那么有：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VSS = 500K + 2500K + 200K = 3200K</span><br><span class="line">RSS = 400K + 1000K + 100K = 1500K</span><br><span class="line">PSS = 400K + 1000K/2 + 100K = 1000K <span class="comment"># 假设两个进程使用共享库</span></span><br><span class="line">USS = 400K + 100K = 500K</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>因为VSS还统计了进程尚未在内存中使用的大小（如进程<code>malloc</code>后，系统并不会第一时间分配内存）所以一般不用来衡量进程的内存占用；</li><li>而RSS因为将进程使用的共享库纳入统计，即使这个库能被复数进程共享，所以单独使用RSS作为测量项也会有误导性；</li><li>相对于RSS，PSS更适合作为进程内存占用的衡量项，而且<a href="https://unix.stackexchange.com/questions/34189/how-often-is-pss-value-updated-for-a-given-process-in-proc-pid-smaps" target="_blank" rel="noopener">不用担心PSS的更新时间</a>;</li><li>USS则非常适合用来采样观察进程是否发生了内存泄漏。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://linuxconfig.org/ps-output-difference-between-vsz-vs-rss-memory-usage" target="_blank" rel="noopener">https://linuxconfig.org/ps-output-difference-between-vsz-vs-rss-memory-usage</a></li><li><a href="https://elinux.org/Android_Memory_Usage" target="_blank" rel="noopener">https://elinux.org/Android_Memory_Usage</a></li><li><a href="https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management" target="_blank" rel="noopener">https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management</a></li><li><a href="https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate" target="_blank" rel="noopener">https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate</a></li><li><a href="https://www.jianshu.com/p/9bf36aa82f90" target="_blank" rel="noopener">https://www.jianshu.com/p/9bf36aa82f90</a></li><li><a href="https://linux.die.net/man/8/smem" target="_blank" rel="noopener">https://linux.die.net/man/8/smem</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;小白如我，写完程序想看看内存占用多少，打开了&lt;code&gt;top&lt;/code&gt;却不知道看哪一项为准。&lt;/p&gt;
&lt;h2 id=&quot;是什么？&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#4</title>
    <link href="https://joe-xu.github.io/2018/09/12/reading-the-go-programming-language-04/"/>
    <id>https://joe-xu.github.io/2018/09/12/reading-the-go-programming-language-04/</id>
    <published>2018-09-12T12:36:41.000Z</published>
    <updated>2018-09-12T14:40:25.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h2><h3 id="lt-P120-gt"><a href="#lt-P120-gt" class="headerlink" title="&lt; P120 &gt;"></a>&lt; P120 &gt;</h3><ul><li><p>函数传参都是值传递；在传递<code>slice</code>时，会复制一个<code>slice</code>的<code>struct</code>，包含了底层数组指针、<code>len</code>、<code>cap</code>，虽然被调用函数可以改变底层数组，但是其中<code>len</code>，<code>cap</code>等对调用者是不可见的，除非用指针或返回新值更新；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(val []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val = <span class="built_in">append</span>(val, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(val []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    val = <span class="built_in">append</span>(val, <span class="number">321</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(val))</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    f1(val)</span><br><span class="line">    val = f2(val)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> val &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\t%d\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  1</span></span><br><span class="line"><span class="comment">//  0   321</span></span><br></pre></td></tr></table></figure></li><li><p>函数的类型又称作函数签名（signature），参数以及返回值的变量名对签名无影响；</p></li><li>Go的栈是可变的，取决于内存大小， 可以增长到数G；</li></ul><h3 id="lt-P125-gt"><a href="#lt-P125-gt" class="headerlink" title="&lt; P125 &gt;"></a>&lt; P125 &gt;</h3><ul><li>go的GC不会回收操作系统资源，如打开的文件、网络连接等，必须进行显式的回收；</li><li>当所有返回值都是具名的，return的操作数可以忽略，称作裸返回（bare return）；</li></ul><h3 id="lt-P134-gt"><a href="#lt-P134-gt" class="headerlink" title="&lt; P134 &gt;"></a>&lt; P134 &gt;</h3><ul><li>函数可以赋值，即函数可以作为参数传递；</li><li><p><code>%*s</code>中的<code>*</code>修饰符可以指定字符串前有多少空格；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%*s"</span>, <span class="number">5</span> , <span class="string">"text"</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="lt-P135-gt"><a href="#lt-P135-gt" class="headerlink" title="&lt; P135 &gt;"></a>&lt; P135 &gt;</h3><p>具名函数只能在包级定义；但是匿名函数可以在函数内部给函数变量赋值；但是如果需要递归调用，用<code>:=</code>定义函数变量会导致不能调用自身,可以尝试下面这种方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visitAll <span class="function"><span class="keyword">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">visitAll</span> = <span class="title">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">if</span> !seen[item] &#123;</span><br><span class="line">            seen[item] = <span class="literal">true</span></span><br><span class="line">            visitAll(m[item])</span><br><span class="line">            order = <span class="built_in">append</span>(order, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-P141-gt"><a href="#lt-P141-gt" class="headerlink" title="&lt; P141 &gt;"></a>&lt; P141 &gt;</h3><p>注意在使用闭包时捕获迭代局部变量的问题，应该用一个新的局部变量保存；</p><h3 id="lt-P144-gt"><a href="#lt-P144-gt" class="headerlink" title="&lt; P144 &gt;"></a>&lt; P144 &gt;</h3><ul><li>在运行到<code>defer</code>语句时，<em>deferred</em>的函数参数值就确定了，只有函数的执行被延迟；</li><li><em>Deferred</em>的函数在<code>return</code>之后执行；</li></ul><h3 id="lt-P151-gt"><a href="#lt-P151-gt" class="headerlink" title="&lt; P151 &gt;"></a>&lt; P151 &gt;</h3><p><em>Deferred</em>的函数调用的<code>runtime.Stack</code>方法可以打印<code>panic</code>时的<code>stack</code>是因为Go的<code>panic</code>机制会先运行<em>deferred function</em>再<em>unwind the stack</em>；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第五章-函数&quot;&gt;&lt;a href=&quot;#第五章-函数&quot; class=&quot;headerlink&quot; title=&quot;第五章 函数&quot;&gt;&lt;/a&gt;第五章 函数&lt;/h2&gt;&lt;h3 id=&quot;lt-P120-gt&quot;&gt;&lt;a href=&quot;#lt-P120-gt&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#3</title>
    <link href="https://joe-xu.github.io/2018/09/10/reading-the-go-programming-language-03/"/>
    <id>https://joe-xu.github.io/2018/09/10/reading-the-go-programming-language-03/</id>
    <published>2018-09-10T12:41:01.000Z</published>
    <updated>2018-09-12T14:40:27.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h2><h3 id="lt-P83-gt"><a href="#lt-P83-gt" class="headerlink" title="&lt; P83 &gt;"></a>&lt; P83 &gt;</h3><ul><li>长度亦算数组类型的一部分因此两个长度不同的数组是不同类型；</li><li>只有两个数组的元素类型可以比较时，这两个数组才可以比较；</li><li>调用函数传值时，会将数组拷贝传递（传值引用），所以在函数内的修改对原数组无影响；</li></ul><h3 id="lt-P86-gt"><a href="#lt-P86-gt" class="headerlink" title="&lt; P86 &gt;"></a>&lt; P86 &gt;</h3><ul><li>数组和切片声明时可以显式声明<em>index</em>，当两者混用时，隐式声明的元素<em>index</em>随前方相邻的显式声明<em>index</em>自增；</li><li><p>与数组不同，切片不能直接用<code>==</code>或<code>!=</code>比较，只有与<code>nil</code>的比较是合法的，除了<code>[]byte</code>可以用<code>bytes.Equal</code>方法比较外，其它类型切片我们都要自行逐个元素比较；</p><blockquote><p><a href="http://blog.csdn.net/erlib/article/details/50957218" target="_blank" rel="noopener">Go语言核心之美 3.2－slice切片</a><br>为什么Go语言不支持<code>slice</code>的比较运算呢？</p><ul><li>第一个原因，<code>slice</code>是引用类型，一个<code>slice</code>甚至可以引用自身。虽然有很多解决办法，但是没有一个是简单有效的;</li><li>第二个原因，因为<code>slice</code>是间接引用，因此一个<code>slice</code>在不同时间可能包含不同的元素－底层数组的元素可能被修改;</li><li>只要一个数据类型可以做相等比较，那么就可以用来做<code>map</code>的<em>key</em>,<code>map</code>这种数据结构对<em>key</em>的要求是：如果最开始时<em>key</em>是相等的，那在<code>map</code>的生命周期内，<em>key</em>要一直相等，因此这里<em>key</em>是不可变的。而对于指针或<code>chan</code>这类引用类型，<code>==</code>可以判断两个指针是否引用了想同的对象，是有用的，但是<code>slice</code>的相等测试充满了不确定性，因此，安全的做法是禁止<code>slice</code>之间的比较操作。</li></ul></blockquote></li><li><p>可以存在<code>len</code>和<code>cap</code>都为<code>0</code>但是<em>non-nil</em>的<code>slice</code>，所以判定<code>slice</code>是否为空应该用<code>len</code>;</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="lt-P94-gt"><a href="#lt-P94-gt" class="headerlink" title="&lt; P94 &gt;"></a>&lt; P94 &gt;</h3><ul><li><code>map</code>的键应该可以用<code>==</code>比较，不建议用浮点数作键；</li><li><p><code>map</code>中的元素不是变量，因此不能被取地址；</p><blockquote><p><code>map</code>可能会随着元素的增多重新分配更大的内存空间，旧值都会拷贝到新的内存空间，因此之前的地址就会失效。</p></blockquote></li><li><p>和切片一样，<code>map</code>间不能直接比较，只有和<code>nil</code>比较是合法的；</p></li></ul><h3 id="lt-P100-gt"><a href="#lt-P100-gt" class="headerlink" title="&lt; P100 &gt;"></a>&lt; P100 &gt;</h3><p>结构体的字段（field）可以取地址并通过指针访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Employee</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(EmployeeByID(dilbert.ManagerID).Position)   <span class="comment">// "Pointy-haired boss"</span></span><br><span class="line"></span><br><span class="line">id := dilbert.ID</span><br><span class="line">EmployeeByID(id).Salary = <span class="number">0</span> <span class="comment">// fired for... no real reason</span></span><br></pre></td></tr></table></figure><p>最后那条语句需要注意，它调用<code>EmployeeByID</code>生成了一个<code>*Employee</code>指针，然后直接更新该结构体中的一个字段。如果将<code>EmployeeByID</code>的返回值从<code>*Employee</code>换成<code>Employee</code>类型，那么编译将报错，因为编译器无法对返回的<code>Employee</code>进行寻址(<strong>不通过变量直接使用一个值，一般都无法进行寻址</strong>)。</p><h3 id="lt-P101-gt"><a href="#lt-P101-gt" class="headerlink" title="&lt; P101 &gt;"></a>&lt; P101 &gt;</h3><p><strong>对于结构体来说，字段顺序很重要，如果顺序不同或者有一些字段合并声明，即使字段名完全相同，那也算两个完全不同的结构体类型;</strong></p><h3 id="lt-P104-gt"><a href="#lt-P104-gt" class="headerlink" title="&lt; P104 &gt;"></a>&lt; P104 &gt;</h3><p>当结构体中所有字段都可以比较时，这个结构体类型才可以相比较；</p><h3 id="lt-P106-gt"><a href="#lt-P106-gt" class="headerlink" title="&lt; P106 &gt;"></a>&lt; P106 &gt;</h3><ul><li><p>准确来说，结构体中的匿名字段并不是真正的匿名，有隐式的与类型名相同的名字；在格式化字符串中加入<code>#</code>，<code>#</code>代表用Go的语法来打印。对于<code>struct</code>类型来说，打印中将包含每个字段的信息；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;   <span class="comment">//  or   w = Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>当匿名字段没有导出时，不能用长赋值形式；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  mStruct.go</span></span><br><span class="line"><span class="keyword">package</span> mStruct</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cyc <span class="keyword">struct</span> &#123;</span><br><span class="line">    point</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m = mStruct.Cyc&#123;&#125;</span><br><span class="line">    m.X = <span class="number">1</span></span><br><span class="line">    m.point.Y = <span class="number">2</span>   <span class="comment">//  cannot refer to unexported field or method point</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, m)  <span class="comment">//  mStruct.Cyc&#123;point:mStruct.point&#123;X:1, Y:0&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第四章-复合类型&quot;&gt;&lt;a href=&quot;#第四章-复合类型&quot; class=&quot;headerlink&quot; title=&quot;第四章 复合类型&quot;&gt;&lt;/a&gt;第四章 复合类型&lt;/h2&gt;&lt;h3 id=&quot;lt-P83-gt&quot;&gt;&lt;a href=&quot;#lt-P83-gt&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#2</title>
    <link href="https://joe-xu.github.io/2018/09/07/reading-the-go-programming-language-02/"/>
    <id>https://joe-xu.github.io/2018/09/07/reading-the-go-programming-language-02/</id>
    <published>2018-09-07T12:10:47.000Z</published>
    <updated>2018-09-12T14:35:49.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-基本数据类型"><a href="#第三章-基本数据类型" class="headerlink" title="第三章 基本数据类型"></a>第三章 基本数据类型</h2><p>主要围绕基本类型来讲的一章，仍记得当时看的时候按捺不住想要跳过的心，但是第三章还是非常重要的，有详细讲解最常用的<code>slice</code>内存模型避免误用，而且还穿插了一些有趣的小例程，譬如教你怎么画一个漂亮的分型图等。</p><p>但是这里我只post自己整理的笔记。XD</p><a id="more"></a><h2 id="lt-P52-gt"><a href="#lt-P52-gt" class="headerlink" title="&lt; P52 &gt;"></a>&lt; P52 &gt;</h2><ul><li><code>int</code>与<code>uint</code>的字节长度在不同实现的编译器下可能不同，即使是在同一个主机上；</li><li><code>%</code>仅能用于整型；</li><li>在Go中，余数符号永远与被除数相同，即<code>-5%3</code>与<code>-5%-3</code>同样得<code>-2</code>；</li></ul><h2 id="lt-P57-gt"><a href="#lt-P57-gt" class="headerlink" title="&lt; P57 &gt;"></a>&lt; P57 &gt;</h2><ul><li><p><code>float</code>类型变量为0时作被除数为<em>可疑运算（dubious operation）</em>，若用整型在编译时会报错，可以表示正负无穷以及<code>NaN</code>（not a number）；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float32</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z)  <span class="comment">// 0 -0 +Inf -Inf NaN</span></span><br></pre></td></tr></table></figure></li><li><p><code>math.NaN</code>函数也可以返回<code>NaN</code>，并且<code>NaN</code>的任何比较结果都是<code>false</code>，可以使用<code>math.IsNaN</code>函数判定；</p></li></ul><h2 id="lt-P63-gt"><a href="#lt-P63-gt" class="headerlink" title="&lt; P63 &gt;"></a>&lt; P63 &gt;</h2><ul><li>如果<code>s</code>是空字符串，使用<code>s[0</code>]会引起<code>panic</code>；</li><li>不存在<code>0</code>或<code>1</code>等到布尔类型的隐式转换，反过来同理；</li></ul><h2 id="lt-P65-gt"><a href="#lt-P65-gt" class="headerlink" title="&lt; P65 &gt;"></a>&lt; P65 &gt;</h2><ul><li>字符串的值是不可更改的，所以字符串拷贝和子字符串都可以与原串共用同一空间，操作廉价，但是<code>string</code>类型变量可以重新赋值；</li><li>内建函数<code>len</code>返回的是字符串的<code>byte</code>数，要在utf-8格式下计数可以用<code>utf8.RuneCountInString</code>方法；</li></ul><h2 id="lt-P70-gt"><a href="#lt-P70-gt" class="headerlink" title="&lt; P70 &gt;"></a>&lt; P70 &gt;</h2><ul><li><strong>使用<code>range</code>遍历字符串时，会隐式对utf8解码，索引<code>i</code>也会跳动</strong>；</li><li>每当utf8解码器遇到一个非预期的<code>byte</code>，不管是显式的调用<code>utf8.DecodeRuneInString</code>方法还是在<code>range</code>中隐式调用，会产生一个<em>replacement character</em>（\uFFFD），就是常见的黑底六角形加上白色问号的符号；</li></ul><h2 id="lt-P78-gt"><a href="#lt-P78-gt" class="headerlink" title="&lt; P78 &gt;"></a>&lt; P78 &gt;</h2><ul><li>经编译器处理，无类型常量的精度比基本类型更大，且四则运算同样，大约有256 bit的精度；</li><li>只有常量是无类型的，当常量被赋值给一个特定类型变量时会被隐式转换；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-基本数据类型&quot;&gt;&lt;a href=&quot;#第三章-基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本数据类型&quot;&gt;&lt;/a&gt;第三章 基本数据类型&lt;/h2&gt;&lt;p&gt;主要围绕基本类型来讲的一章，仍记得当时看的时候按捺不住想要跳过的心，但是第三章还是非常重要的，有详细讲解最常用的&lt;code&gt;slice&lt;/code&gt;内存模型避免误用，而且还穿插了一些有趣的小例程，譬如教你怎么画一个漂亮的分型图等。&lt;/p&gt;
&lt;p&gt;但是这里我只post自己整理的笔记。XD&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>说说login shell和non-login shell</title>
    <link href="https://joe-xu.github.io/2018/09/06/login-shell-and-non-login-shell/"/>
    <id>https://joe-xu.github.io/2018/09/06/login-shell-and-non-login-shell/</id>
    <published>2018-09-06T12:46:39.000Z</published>
    <updated>2018-09-19T13:10:28.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近又要在公司的CentOS上配一遍开发环境，这就避不了要编辑一番<code>PATH</code>，那么问题来了，这是要写在<code>/etc/profile</code>、<code>~/.profile</code>、<code>~/.bash_profile</code>还是<code>~/.bashrc</code>或<code>~/.bash_login</code>呢?首先，可以排除影响全局的<code>/etc/profile</code>，这改了听起来就是给后来的自己挖坑(还有一个<code>/etc/bash.bashrc</code>)。接着我们就要厘清后四个的区别了，这就要从<em>login shell</em>和<em>non-login shell</em>的区别说起。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不用Google，有事先找<code>man</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; man bash</span><br></pre></td></tr></table></figure><p>我们在<code>bash</code>的手册中<em>INVOCATION</em>一节就可以找到<em>login shell</em>的定义：</p><blockquote><p>A login shell is one whose first character of argument zero is a <code>-</code>, or one started with the <code>--login</code> option.</p></blockquote><p>顺便还有<em>interactive shell</em>的定义：</p><blockquote><p>An interactive shell is one started without non-option arguments and without the <code>-c</code> option whose standard input and error are both connected to terminals (as determined by  isatty(3)),  or one started with the <code>-i</code> option.</p></blockquote><p>可知有：</p><ul><li><em>交互式的 login shell</em>：本地登录、ssh登录、<code>bash --login</code>、<code>su - &lt;user&gt;</code>;</li><li><em>交互式的 non-login shell</em>：<code>su &lt;user&gt;</code>;</li><li><em>非交互的 non-login shell</em>：<code>ssh example.com my-script-which-is-on-the-remote-machine</code>;</li><li><em>非交互的 login shell</em>：脚本中使用<code>--login</code>(如<code>#!/bin/bash --login</code>);</li></ul><p>上述的情况并没有列全，可以通过如下方法区分login和non-login shell：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">-bash <span class="comment">#第一个字符是 "-"， 所以是 login shell。</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">bash <span class="comment">#不是一个login shell。</span></span><br></pre></td></tr></table></figure><h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>当一个<code>bash</code>是以<strong>交互式的login shell</strong>被调用时，它首先会读取<code>/etc/profile</code>文件，然后按照<code>~/.bash_profile</code>，<code>~/.bash_login</code>和<code>~/.profile</code>的顺序依次查找并读取，但这是短路式的，按顺序成功读取了三者之一就不继续往后查找了。最后在退出时会执行<code>~/.bash_logout</code>中的命令。</p><p>而<strong>交互式的non-login shell</strong>则先后读取<code>/etc/bash.bashrc</code>和<code>~/.bashrc</code>。</p><p><strong>非交互的non-login shell</strong>只展开环境变量<code>BASH_ENV</code>并执行其指向的文件。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>如果需要统一交互式的<em>login shell</em>和<em>non-login shell</em>环境，我们可以在<code>~/.bashrc</code>中编写配置，然后在<code>~/.bash_profile</code>读取<code>~/.bashrc</code>。非交互式的情况一般与脚本有关，一般是主动载入环境变量(因为环境变量问题，dockerfile中也建议使用绝对路径)，所以暂且不管。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://blog.sciencenet.cn/blog-3238131-1037461.html" target="_blank" rel="noopener">login shell与non-login shell的区别</a></li><li><a href="https://unix.stackexchange.com/questions/38175/difference-between-login-shell-and-non-login-shell" target="_blank" rel="noopener">difference-between-login-shell-and-non-login-shell</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近又要在公司的CentOS上配一遍开发环境，这就避不了要编辑一番&lt;code&gt;PATH&lt;/code&gt;，那么问题来了，这是要写在&lt;code&gt;/etc/profile&lt;/code&gt;、&lt;code&gt;~/.profile&lt;/code&gt;、&lt;code&gt;~/.bash_profile&lt;/code&gt;还是&lt;code&gt;~/.bashrc&lt;/code&gt;或&lt;code&gt;~/.bash_login&lt;/code&gt;呢?首先，可以排除影响全局的&lt;code&gt;/etc/profile&lt;/code&gt;，这改了听起来就是给后来的自己挖坑(还有一个&lt;code&gt;/etc/bash.bashrc&lt;/code&gt;)。接着我们就要厘清后四个的区别了，这就要从&lt;em&gt;login shell&lt;/em&gt;和&lt;em&gt;non-login shell&lt;/em&gt;的区别说起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://joe-xu.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#1</title>
    <link href="https://joe-xu.github.io/2018/09/05/reading-the-go-programming-language-01/"/>
    <id>https://joe-xu.github.io/2018/09/05/reading-the-go-programming-language-01/</id>
    <published>2018-09-05T13:04:40.000Z</published>
    <updated>2018-09-12T14:40:30.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-程序结构"><a href="#第二章-程序结构" class="headerlink" title="第二章 程序结构"></a>第二章 程序结构</h2><h3 id="lt-P28-gt"><a href="#lt-P28-gt" class="headerlink" title="&lt; P28 &gt;"></a>&lt; P28 &gt;</h3><p>Go中的<a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">Predeclared identifiers</a>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Types:</span><br><span class="line">bool byte complex64 complex128 error float32 float64</span><br><span class="line">int int8 int16 int32 int64 rune string</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">Constants:</span><br><span class="line">true false iota</span><br><span class="line"></span><br><span class="line">Zero value:</span><br><span class="line">nil</span><br><span class="line"></span><br><span class="line">Functions:</span><br><span class="line">append cap close complex copy delete imag len</span><br><span class="line">make new panic print println real recover</span><br></pre></td></tr></table></figure><p>这里面的关键字都是不保留的，可以用作我们的自定变量名，当然这是强烈不推荐的。<del>除非已经被<em>命名困难症</em>逼到了绝境。</del></p><p>另外，变量名长度是不作限定的（the larger the scope of a name, the longer and more meanningful it should be），一个全局变量的名字应该比一个局部变量更易见名知义（所以长点也没关系）。</p><h3 id="lt-P31-gt"><a href="#lt-P31-gt" class="headerlink" title="&lt; P31 &gt;"></a>&lt; P31 &gt;</h3><ul><li><code>:=</code>(the short variable declaration)是用作声明的，而不是像<code>=</code>一样用作赋值；</li><li><code>:=</code>左边至少要存在一个未声明的变量；</li></ul><h3 id="lt-P35-gt"><a href="#lt-P35-gt" class="headerlink" title="&lt; P35 &gt;"></a>&lt; P35 &gt;</h3><p>如果两个变量的类型不承载任何信息，根据编译器的实现，指针地址可能相同，例如<code>struct{}</code>和<code>[0]int</code>；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> t2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, &amp;t1 == &amp;t2)   <span class="comment">//true  t1,t2为[0]int时同理</span></span><br></pre></td></tr></table></figure><h3 id="lt-P36-gt"><a href="#lt-P36-gt" class="headerlink" title="&lt; P36 &gt;"></a>&lt; P36 &gt;</h3><ul><li>用生命周期长的指针指向生命周期短的变量会阻碍对该变量的GC；</li><li><strong>变量被分配到堆或栈与否不由声明方式决定</strong>，如<code>var</code>或<code>new</code>；(mark一下，之后再拓展一篇，<del>如果还有机会看见这个mark</del>)</li></ul><h3 id="lt-P39-gt"><a href="#lt-P39-gt" class="headerlink" title="&lt; P39 &gt;"></a>&lt; P39 &gt;</h3><p>显式类型转换<code>T(x)</code>是一种<a href="https://golang.org/ref/spec#Conversions" target="_blank" rel="noopener">转换(conversion)</a>，不是函数调用；</p><h3 id="lt-P41-gt"><a href="#lt-P41-gt" class="headerlink" title="&lt; P41 &gt;"></a>&lt; P41 &gt;</h3><p>首先看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> x T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会隐式调用T的String方法（如果有）</span></span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>,x)</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>,x)</span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会调用</span></span><br><span class="line">fmt.Printf(<span class="string">"%g"</span>,x)</span><br><span class="line">fmt.Println(<span class="keyword">float64</span>(x))</span><br></pre></td></tr></table></figure><p>那么我们在给<code>T</code>实现<code>String()</code>且需要打印自身时，要注意避免无穷递归调用。</p><h3 id="lt-P46-gt"><a href="#lt-P46-gt" class="headerlink" title="&lt; P46 &gt;"></a>&lt; P46 &gt;</h3><ul><li>变量的作用域与生命周期不相等，作用域是编译时属性(compile-time property)，而生命周期是运行时属性(run-time porperty)；</li><li><p>有或没有显式地用花括号界定的作用域都可以笼统地归纳为<em>lexical block</em>；例如包含整个源码的<em>universe <a href="https://golang.org/ref/spec#Blocks" target="_blank" rel="noopener">block</a></em>，每个<code>package</code>、文件、<code>for</code>、<code>if</code>、<code>switch/select</code>，<code>switch/select</code>中的每个<code>case</code>；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">x := <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">for</span>  _ , x := <span class="keyword">range</span> x&#123;  <span class="comment">// for statement中有隐式lexical block</span></span><br><span class="line">x := x +<span class="string">'A'</span>-<span class="string">'a'</span>     <span class="comment">// &#123;&#125;中的显式lexical block</span></span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>,x)  <span class="comment">// 正常输出"HELLO"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导入的包的作用域是<em>file-level</em>的，所以每个文件都要单独导入，即使是同一个包下；</p></li><li><em>Control-flow label</em>（用于<code>break</code>、<code>continue</code>和<code>goto</code>）的作用域是整个函数；</li><li>编译器会从最内的<em>lexical block</em>至<em>universe block</em>查找变量的声明；所以最内部变量可以<em>shadow</em>（又或称屏蔽/<em>hide</em>）外部同名变量；</li></ul><h3 id="lt-P49-gt"><a href="#lt-P49-gt" class="headerlink" title="&lt; P49 &gt;"></a>&lt; P49 &gt;</h3><p><strong>在使用<code>:=</code>时要注意作用域</strong>；例如，如果要在函数内更新<em>package-level</em>变量，使用<code>:=</code>会重新声明一个同名局部变量；</p><h2 id="一段闲扯"><a href="#一段闲扯" class="headerlink" title="一段闲扯"></a>一段闲扯</h2><blockquote><p>！！距离拖延症发作过去了<strong>03</strong>天！！</p></blockquote><p>从第二章开始的内容已经比第一章多了，不过想想，这也是肯定的。按照这个劲头，似乎半个月就能把这个系列整理完。另外hexo是真的好用，都要治好我多年的拖延症了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二章-程序结构&quot;&gt;&lt;a href=&quot;#第二章-程序结构&quot; class=&quot;headerlink&quot; title=&quot;第二章 程序结构&quot;&gt;&lt;/a&gt;第二章 程序结构&lt;/h2&gt;&lt;h3 id=&quot;lt-P28-gt&quot;&gt;&lt;a href=&quot;#lt-P28-gt&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#0</title>
    <link href="https://joe-xu.github.io/2018/09/04/reading-the-go-programming-language/"/>
    <id>https://joe-xu.github.io/2018/09/04/reading-the-go-programming-language/</id>
    <published>2018-09-04T12:41:44.000Z</published>
    <updated>2018-09-05T13:19:27.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>当初入坑Go的时候，怀着朝圣的心买了这本书(<a href="https://book.douban.com/subject/26859123/" target="_blank" rel="noopener">《Go程序设计语言》</a>)来啃。本以为我这样的拖延症会拖到最后而不了了之，没想到硬是被我啃完了，因为书中的内容确实引人入胜，除了深入浅出讲解Go外，还有许多扩展开来的相关知识和编程思想。</p><a id="more"></a><p>在啃书途中，也用Onenote整理的不少的笔记，主要是一些关键知识的摘抄，打算在懒癌没发作的时间整理成一系列blog，希望能在年末前更新完十三章，届时可能能作为我18年的最自豪成绩。</p><p>日后如果温故而知新了，会继续追加更新。</p><p><del>要说为什么我当时用Onenote，因为年轻的我还是忠实的田牌教徒，用着田牌手机还要四处张扬那种。</del></p><h2 id="第一章-综述"><a href="#第一章-综述" class="headerlink" title="第一章 综述"></a>第一章 综述</h2><h3 id="lt-P6-gt"><a href="#lt-P6-gt" class="headerlink" title="&lt; P6 &gt;"></a>&lt; P6 &gt;</h3><p>Go中有statement与expression的区分</p><blockquote><p><a href="https://golang.org/ref/spec#Expressions" target="_blank" rel="noopener">Go Spec#Expressions</a>：<br>An expression specifies the computation of a value by applying operators and functions to operands.</p></blockquote><blockquote><p><a href="https://golang.org/ref/spec#Statements" target="_blank" rel="noopener">Go Spec#Statements</a>：<br>Statements control execution.</p></blockquote><p>那么，值得注意的是<code>i++</code>在go中是<code>statement</code>，不同于其它C-like语言。这就是<code>j = i++</code>等类似语句非法的原因。</p><h3 id="lt-P7-gt"><a href="#lt-P7-gt" class="headerlink" title="&lt; P7 &gt;"></a>&lt; P7 &gt;</h3><ul><li>用<code>+=</code>进行字符串拼接时会申请内存创建新的字符串，要注意频繁的操作会引起更密集的GC；</li></ul><h3 id="lt-P9-gt"><a href="#lt-P9-gt" class="headerlink" title="&lt; P9 &gt;"></a>&lt; P9 &gt;</h3><ul><li><code>map</code>是对<code>make()</code>创建的数据结构的引用；</li><li><code>map</code>里的键可以实任意可以使用<code>==</code>作比较的类型，而存储的值可以实任意类型；<blockquote><p><a href="https://golang.org/ref/spec#Comparison_operators" target="_blank" rel="noopener">扩展阅读：Go的Comparable rules</a></p></blockquote></li><li><code>map</code>是无序的，值得注意的是，<code>map</code>在使用<code>range</code>进行遍历的访问顺序亦是随机的，这应该算Go中最应该注意的坑之一了，据说这是在设计Go的时候有意为之的（<em>It’s not a bug, it’s a feature!</em>）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;当初入坑Go的时候，怀着朝圣的心买了这本书(&lt;a href=&quot;https://book.douban.com/subject/26859123/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Go程序设计语言》&lt;/a&gt;)来啃。本以为我这样的拖延症会拖到最后而不了了之，没想到硬是被我啃完了，因为书中的内容确实引人入胜，除了深入浅出讲解Go外，还有许多扩展开来的相关知识和编程思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://joe-xu.github.io/2018/09/03/hello-world/"/>
    <id>https://joe-xu.github.io/2018/09/03/hello-world/</id>
    <published>2018-09-03T12:33:02.164Z</published>
    <updated>2018-09-03T12:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
