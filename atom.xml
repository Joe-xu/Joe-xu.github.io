<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinking_Out_Loud</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joe-xu.github.io/"/>
  <updated>2018-09-27T15:33:28.301Z</updated>
  <id>https://joe-xu.github.io/</id>
  
  <author>
    <name>Joe Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统负载</title>
    <link href="https://joe-xu.github.io/2018/09/27/linux-load-averages/"/>
    <id>https://joe-xu.github.io/2018/09/27/linux-load-averages/</id>
    <published>2018-09-27T14:18:18.000Z</published>
    <updated>2018-09-27T15:33:28.301Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html" target="_blank" rel="noopener">http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html</a></p></blockquote><h2 id="初识负载"><a href="#初识负载" class="headerlink" title="初识负载"></a>初识负载</h2><p>我们平时使用<code>top</code>或者<code>uptime</code>时可以看到打印输出的系统平均负载（方便起见，后文都简称负载），分别是1分钟、5分钟和15分钟，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 22:20:29 up 9 min,  0 users,  load average: 0.52, 0.58, 0.59</span><br></pre></td></tr></table></figure><p>我们一般这样解读负载：</p><ul><li>如果负载是<code>0.0</code>，那么系统就是空闲状态；</li><li>如果1分钟负载比5分钟或15分钟负载大，易见系统负载正在增长；</li><li>反之，如果1分钟负载比5分钟或15分钟负载小，那么系统负载正在降低；</li><li>如果负载高于CPU核数，那么系统中可能存在性能问题；</li></ul><p>但是系统负载到底是怎么统计的呢？</p><hr><p>先说结论：</p><p>在Linux中，负载是单位时间内的运行及等待运行的任务数，包含<code>TASK_UNINTERRUPTIBLE</code>状态（不受中断信号影响，一般是等待I/O和互斥锁的任务，在<code>ps</code>和<code>top</code>用<code>D</code>作标记）中的任务。也就是说，Linux的系统负载不仅仅是CPU的使用，还把I/O等系统资源加入到了统计中。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么要将CPU外的资源纳入统计范围，下面是对这次commit的说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">From: Matthias Urlichs &lt;urlichs@smurf.sub.org&gt;</span><br><span class="line">Subject: Load average broken ?</span><br><span class="line">Date: Fri, 29 Oct 1993 11:37:23 +0200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The kernel only counts &quot;runnable&quot; processes when computing the load average.</span><br><span class="line">I don&apos;t like that; the problem is that processes which are swapping or</span><br><span class="line">waiting on &quot;fast&quot;, i.e. noninterruptible, I/O, also consume resources.</span><br><span class="line"></span><br><span class="line">It seems somewhat nonintuitive that the load average goes down when you</span><br><span class="line">replace your fast swap disk with a slow swap disk...</span><br><span class="line"></span><br><span class="line">Anyway, the following patch seems to make the load average much more</span><br><span class="line">consistent WRT the subjective speed of the system. And, most important, the</span><br><span class="line">load is still zero when nobody is doing anything. ;-)</span><br></pre></td></tr></table></figure><p>也就说如果仅统计CPU的使用，一个重I/O的程序从高速磁盘转到低速硬盘运行时，系统负载就会出现下降的情形。显然这从用户的角度看是不合理的，而且不便于反映系统性能问题，所以应该把整个系统的资源使用纳入统计范围。</p><h2 id="更好的度量项"><a href="#更好的度量项" class="headerlink" title="更好的度量项"></a>更好的度量项</h2><p>虽然系统负载考虑了整个系统资源，但是也不能单纯用负载除以CPU核数的方法判定一个系统的运行状况，这个时候用检验值去做平行比较反而更好。</p><p>因为负载值的模凌两可，我们可以考虑用下列的值来代替：</p><blockquote><ul><li>per-CPU utilization: eg, using mpstat -P ALL 1</li><li>per-process CPU utilization: eg, top, pidstat 1, etc.</li><li>per-thread run queue (scheduler) latency: eg, in /proc/PID/schedstats, delaystats, perf sched</li><li>CPU run queue latency: eg, in /proc/schedstat, perf sched.</li><li>CPU run queue length: eg, using vmstat 1 and the ‘r’ column.</li></ul></blockquote><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>这里只摘抄转译了原文部分内容，并没有全部搬运。有兴趣继续深入的同学可以在原文阅览更多内容，地址见文首。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用VScode + rmate编辑远程文件</title>
    <link href="https://joe-xu.github.io/2018/09/25/edit-remote-file/"/>
    <id>https://joe-xu.github.io/2018/09/25/edit-remote-file/</id>
    <published>2018-09-25T14:30:46.000Z</published>
    <updated>2018-09-25T15:06:37.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一直用着便宜的VPS，可惜就是延迟太高，每次用<code>vim</code>总能有一秒多的lag，但生活总不能将就下去，找了一种简单好用的编辑远程文件方法，记录一下。</p><h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h2><p>在远程主机安装<a href="https://github.com/textmate/rmate" target="_blank" rel="noopener">rmate</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -Lo ~/bin/rmate https://raw.githubusercontent.com/textmate/rmate/master/bin/rmate</span><br><span class="line">&gt; chmod a+x ~/bin/rmate</span><br></pre></td></tr></table></figure><p>在本地主机VScode中安装插件<a href="https://marketplace.visualstudio.com/items?itemName=rafaelmaiolla.remote-vscode" target="_blank" rel="noopener">remote-vscode</a>;</p><p>编辑本地主机<code>~/.ssh/config</code>文件，其中<code>52698</code>是rmate的默认端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host vps</span><br><span class="line">        User root</span><br><span class="line">        HostName xx.xx.xx.xx</span><br><span class="line">        Port xxxx</span><br><span class="line">        RemoteForward 52698 localhost:52698</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>首先要确保VScode中的插件的服务器已经运行，如果要自启可以设置<code>&quot;remote.onstartup&quot;: true</code>，或者<code>ctrl + shift + P</code>后选择<code>Remote: Start Server</code>手动启动服务器；</p></li><li><p>如果你要在远程主机上想要编辑一个文件：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh vps</span><br><span class="line">&gt; rmate /path/to/fileA</span><br></pre></td></tr></table></figure></li><li><p>现在可以在VScode自动弹出来文件<code>fileA</code>中自由编辑了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一直用着便宜的VPS，可惜就是延迟太高，每次用&lt;code&gt;vim&lt;/code&gt;总能有一秒多的lag，但生活总不能将就下去，找了一种简单好用的
      
    
    </summary>
    
    
      <category term="tools" scheme="https://joe-xu.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>我是如何用掉一天的：OpenWRT配v2ray</title>
    <link href="https://joe-xu.github.io/2018/09/22/openwrt-plus-v2ray/"/>
    <id>https://joe-xu.github.io/2018/09/22/openwrt-plus-v2ray/</id>
    <published>2018-09-22T14:45:35.000Z</published>
    <updated>2018-09-25T15:04:18.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个小目标"><a href="#一个小目标" class="headerlink" title="一个小目标"></a>一个小目标</h1><p>今天把我的小Y从<em>lede-17.01</em>升级到了<em>openwrt-18.06.1</em>。对，lede又重新和openwrt合并了，XP。<br>很欣喜的是发现默认主题居然变好看了，交互体验也提升了很多，<del>这个开源小组终于有美工了</del>，升级过程暂且不表，今天我的小目标是在路由器上用<a href="https://www.v2ray.com/" target="_blank" rel="noopener">v2ray</a>搭好爱国透明代理。</p><p>然而第一步就掉了链子，<a href="https://wiki.openwrt.org/doc/howto/wget-ssl-certs" target="_blank" rel="noopener">openwrt中默认的<code>wget</code>命令是由busybox提供的</a>，不支持https，所以需要重新安装一个。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; opkg update</span><br><span class="line">&gt; opkg install wget</span><br></pre></td></tr></table></figure><p>然后就可以高高兴兴去下二进制安装包了，不料这mipsle的安装包竟然有17MB，一个主程序和辅助工具再加上IP数据集，我的小Y只有16MB的Flash，<del>真是天要亡我</del>。还是不死心，go在编译时去掉符号表能省不少空间，还能再挤挤，果然在谷歌第一页就翻到了大牛留下的笔记：</p><blockquote><p><a href="https://gobomb.github.io/post/cross-complie-v2ray/" target="_blank" rel="noopener">https://gobomb.github.io/post/cross-complie-v2ray/</a></p></blockquote><p>多亏大牛我才想起在openwrt官网下载的系统升级固件默认是没开FPU支持的，运行go程序会报<code>Illegal instruction</code>，就是说我要从固件开始自己编译，<del>抬头望天</del>。</p><h1 id="挣扎"><a href="#挣扎" class="headerlink" title="挣扎"></a>挣扎</h1><p>翻出了还在15.05-cc版的本地仓库，用30KB的平均速度pull到了最新的代码，长征第一步。</p><p>我沿用了之前搭建的环境，如果有需要从零开始搭建的同学可以参考<a href="https://openwrt.org/docs/guide-developer/build-system/install-buildsystem" target="_blank" rel="noopener">官方指引</a>,或者使用docker上的build-root镜像（<del>张口就来，其实我没实际用过</del>）。</p><p>代码更新完后更新一下软件包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;./scripts/feeds update -a</span><br><span class="line">&gt;./scripts/feeds install -a</span><br></pre></td></tr></table></figure><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>那么可以开始编译固件了</p><p>首先把最重要的FPU支持打开,先进入内核选项菜单:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make kernel_menuconfig</span><br></pre></td></tr></table></figure><p>按下列路径进去把FPU支持开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel type ---&gt; MIPS FPU Emulator</span><br></pre></td></tr></table></figure><p>然后再去把需要预装的包都勾上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make menuconfig</span><br></pre></td></tr></table></figure><p>我的小Y是MT7620的板，开启5G-wifi需要安装<code>kmod-mt76</code>,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel modules ---&gt; wireless drivers ---&gt; kmod-mt76</span><br></pre></td></tr></table></figure><p>再去把usb自动挂载配置好（未雨绸缪）:</p><blockquote><ol><li>添加USB相关支持<br>• Kernel modules —&gt; USB Support —&gt; &lt;<em>&gt; kmod-usb-core.   #默认已经选了<br>• Kernel modules —&gt; USB Support —&gt; &lt;</em>&gt; kmod-usb-ohci.   #默认已选 old usb1.0<br>• Kernel modules —&gt; USB Support —&gt; &lt;<em>&gt; kmod-usb-uhci.   # usb1.1<br>• Kernel modules —&gt; USB Support —&gt; &lt;</em>&gt; kmod-usb-storage.<br>• Kernel modules —&gt; USB Support —&gt; &lt;<em>&gt; kmod-usb-storage-extras.<br>• Kernel modules —&gt; USB Support —&gt; &lt;</em>&gt; kmod-usb2.   #默认已经选了 usb2.0<br>• 再加个usb3</li><li>添加USB挂载<br>• Base system —&gt; &lt;*&gt;block-mount</li><li>添加自动挂载工具<br>• Utilities —&gt; Filesystem —&gt; &lt;*&gt; badblocks</li><li>添加文件系统支持<br>• Kernel modules —&gt; Filesystems —&gt; &lt;<em>&gt; kmod-fs-ext4 (移动硬盘EXT4格式选择)<br>• Kernel modules —&gt; Filesystems —&gt; &lt;</em>&gt; kmod-fs-vfat(FAT16 / FAT32 格式 选择)</li><li>添加UTF8编码,CP437编码，ISO8859-1编码（否则即使/dev/中出现设备也无法挂载）<br>• Kernel modules —&gt; Native Language Support —&gt; &lt;<em>&gt; kmod-nls-utf8<br>• Utilities  —&gt; disc —&gt; &lt;</em>&gt; fdisk……………………………… manipulate disk partition table<br>• Utilities  —&gt; &lt;*&gt; usbutils…………………………….. USB devices listing utilities</li></ol></blockquote><p>又因为后面需要设置iptables转发，所以需要在menuconfig中安装如下包,因为是自编译固件，所以有些不能通过官方feed安装，提前放在这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip-tiny / ip-full</span><br><span class="line">ipset</span><br><span class="line">iptables</span><br><span class="line">iptables-mod-tproxy</span><br><span class="line">kmod-ipt-ipset</span><br><span class="line">kmod-ipt-tproxy</span><br><span class="line">libipset</span><br></pre></td></tr></table></figure><p>首先先把之前的toolchain等清理掉，因为占用的磁盘真的大。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make dirclean <span class="comment"># /bin /build_dir /staging_dir /toolchain /tmp /logs.</span></span><br></pre></td></tr></table></figure><p>建议第一遍编译先用verbose模式输出日志，<del>一遍成功是不存在的</del>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; make -j1 V=s</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>编译过程中出现了这样的complain：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Image file /openwrt/cc/build_dir/target-mipsel_24kc_musl/linux-ramips_mt7620/tmp/openwrt-ramips-mt7620-ex2700-squashfs-sysupgrade.bin is too big</span><br></pre></td></tr></table></figure><p>这因为胡乱塞了很多东西，导致没办法兼容Flash只有4M的设备。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ./target/linux/ramips/image/Makefile</span><br></pre></td></tr></table></figure><p>修改220行的<code>ralink_default_fw_size_4M=3866624</code>值为更大的就好了。<br>而我的做法是：重进menuconfig，把忘记选上的profile选好，这样就只编译我需要的Y1固件了，XD</p><hr><p>漫无止境的编译和网络I/O…</p><h1 id="十年后"><a href="#十年后" class="headerlink" title="十年后"></a>十年后</h1><p>新鲜出炉的固件在<code>/bin</code>目录下，又回到最初的起点。</p><h2 id="编译V2ray"><a href="#编译V2ray" class="headerlink" title="编译V2ray"></a>编译V2ray</h2><p>根据<a href="https://www.v2ray.com/developer/intro/compile.html" target="_blank" rel="noopener">v2ray的官方指引</a>准备好编译环境。</p><p>分别编译v2ray和v2ctl：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/v2ray/core/main</span><br><span class="line">&gt; GOARCH=mipsle GOMIPS=softfloat go build -ldflags <span class="string">'-w -s'</span> -o v2ray</span><br><span class="line">&gt; <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/v2ray.com/ext/tools/control/main</span><br><span class="line">&gt; GOARCH=mipsle GOMIPS=softfloat go build -ldflags <span class="string">'-w -s'</span> -o v2ctl</span><br></pre></td></tr></table></figure><p>题外话，我发现v2ray自带的构建工具vbuild并没有考虑GOPATH变量中存在两个路径的情况：我的GOPATH中第一个路径设定为第三方lib的目录，接着的是个人项目的目录，这样在<code>go get</code>时会自动把依赖库都放在第一个目录中，这就把它们和个人项目分开来了。</p><h2 id="配置透明代理"><a href="#配置透明代理" class="headerlink" title="配置透明代理"></a>配置透明代理</h2><p>因为挂载了U盘，磁盘空间有余裕了，我打算先把透明代理配置好，先不用upx压缩。</p><p>我的iptables设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MY_VPS=xx.xx.xx.xx</span><br><span class="line">MY_PROXY_PORT=1060</span><br><span class="line">SKIP_IP=<span class="string">'0.0.0.0/8 10.0.0.0/8 127.0.0.0/8 169.254.0.0/16</span></span><br><span class="line"><span class="string">        172.16.0.0/12 192.168.0.0/16 224.0.0.0/4 240.0.0.0/4'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new chain</span></span><br><span class="line">iptables -t nat -N V2RAY</span><br><span class="line">iptables -t mangle -N V2RAY_MARK</span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp rule</span></span><br><span class="line">iptables -t nat -A V2RAY -d <span class="variable">$MY_VPS</span> -j RETURN   <span class="comment"># direct connect</span></span><br><span class="line">iptables -t nat -A V2RAY -p tcp -j RETURN -m mark --mark 0xff <span class="comment"># avoid loop</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$SKIP_IP</span>;<span class="keyword">do</span></span><br><span class="line">    iptables -t nat -A V2RAY -d <span class="variable">$IP</span> -j RETURN</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A V2RAY -p tcp -j REDIRECT --to-ports <span class="variable">$MY_PROXY_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># udp rule</span></span><br><span class="line">ip rule del fwmark 1</span><br><span class="line">ip rule add fwmark 1 table 100</span><br><span class="line">ip route add <span class="built_in">local</span> 0.0.0.0/0 dev lo table 100</span><br><span class="line">ip route flush cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$SKIP_IP</span>;<span class="keyword">do</span></span><br><span class="line">    iptables -t mangle -A V2RAY_MARK -d <span class="variable">$IP</span> -j RETURN</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">iptables -t mangle -A V2RAY_MARK -p udp -j TPROXY --on-port <span class="variable">$MY_PROXY_PORT</span> --tproxy-mark 0x01/0x01</span><br><span class="line"></span><br><span class="line"><span class="comment"># apply chain</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j V2RAY <span class="comment"># 对局域网其他设备进行透明代理</span></span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j V2RAY <span class="comment"># 对本机进行透明代理</span></span><br><span class="line"></span><br><span class="line">iptables -t mangle -A PREROUTING -p udp -j V2RAY_MARK</span><br></pre></td></tr></table></figure><p>我的v2ray设置，部分省略：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "inbound": &#123; ... &#125;,</span><br><span class="line">  "inboundDetour": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"dokodemo-door"</span>,</span><br><span class="line">      <span class="attr">"listen"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">      "port": 1060, // 转发到这里</span><br><span class="line">      "sniffing": &#123;</span><br><span class="line">        "enabled": true,</span><br><span class="line">        "destOverride": [</span><br><span class="line">          "http",</span><br><span class="line">          <span class="string">"tls"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      "settings": &#123;</span><br><span class="line">        "network": "tcp,udp",</span><br><span class="line">        "followRedirect": true,</span><br><span class="line">        "timeout": 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "outbound": &#123; ... &#125;,</span><br><span class="line">  "outboundDetour": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"sockopt"</span>: &#123;</span><br><span class="line">          <span class="attr">"mark"</span>: <span class="number">255</span> // MARK</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"block"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "routing": &#123;</span><br><span class="line">    "strategy": "rules",</span><br><span class="line">    "settings": &#123;</span><br><span class="line">      "domainStrategy": "AsIs",</span><br><span class="line">      "rules": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span>,</span><br><span class="line">          <span class="attr">"protocol"</span>: [</span><br><span class="line">            <span class="string">"bittorrent"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"domain"</span>: [</span><br><span class="line">            <span class="string">"geosite:cn"</span>,</span><br><span class="line">            <span class="string">"geosite:speedtest"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"ip"</span>: [</span><br><span class="line">            <span class="string">"geoip:cn"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成功彼岸"><a href="#成功彼岸" class="headerlink" title="成功彼岸"></a>成功彼岸</h2><p><strong>正式宣布爱国特区成立，papapapa！</strong><br>不过有点悲伤的是运行v2ray之后的5分钟载荷一直在1.5左右浮动，不过实际的网络响应速度还是能接受。<br>先写到这里，其它内容放到之后再整理。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://gobomb.github.io/post/cross-complie-v2ray/" target="_blank" rel="noopener">https://gobomb.github.io/post/cross-complie-v2ray/</a></li><li><a href="http://www.tldp.org/HOWTO/Adv-Routing-HOWTO/index.html" target="_blank" rel="noopener">http://www.tldp.org/HOWTO/Adv-Routing-HOWTO/index.html</a></li><li><a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/c/iptables.html</a></li><li><a href="https://toutyrater.github.io/app/transparent_proxy.html" target="_blank" rel="noopener">https://toutyrater.github.io/app/transparent_proxy.html</a></li><li><a href="https://wiki.openwrt.org/doc/howto/netfilter#configuration" target="_blank" rel="noopener">https://wiki.openwrt.org/doc/howto/netfilter#configuration</a></li><li><a href="https://wiki.openwrt.org/inbox/doc/iptables_and_firewall" target="_blank" rel="noopener">https://wiki.openwrt.org/inbox/doc/iptables_and_firewall</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个小目标&quot;&gt;&lt;a href=&quot;#一个小目标&quot; class=&quot;headerlink&quot; title=&quot;一个小目标&quot;&gt;&lt;/a&gt;一个小目标&lt;/h1&gt;&lt;p&gt;今天把我的小Y从&lt;em&gt;lede-17.01&lt;/em&gt;升级到了&lt;em&gt;openwrt-18.06.1&lt;/em&gt;。对，
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
      <category term="openwrt" scheme="https://joe-xu.github.io/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程内存耗用的表述：VSS/RSS/PSS/USS</title>
    <link href="https://joe-xu.github.io/2018/09/19/vss-rss-pss-uss/"/>
    <id>https://joe-xu.github.io/2018/09/19/vss-rss-pss-uss/</id>
    <published>2018-09-19T13:09:30.000Z</published>
    <updated>2018-09-19T15:34:55.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小白如我，写完程序想看看内存占用多少，打开了<code>top</code>却不知道看哪一项为准。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>一开始我也是很懵。</p><p>先一起看看它们的全称和释义：</p><blockquote><p>VSS(VSZ) - Virtual Set Size<br>The Virtual Set Size is a memory size assigned to a process ( program ) during the initial execution. The Virtual Set Size memory is simply a number of how much memory a process has available for its execution.</p></blockquote><p>VSS即由进程视角看到的所有可访问的内存大小，包括被置入交换区的部分，是由系统分配的虚拟内存。</p><blockquote><p>RSS - Resident Set Size<br>RSS is a memory currently used by a process. This is a actual number in kilobytes of how much RAM the current process is using.</p></blockquote><p>RSS则是进程在内存中实际占有的物理内存大小，正如其名是常驻集大小，所以不包括被置换进交换区的部分。</p><blockquote><p>PSS - Proportional Set Size<br>Pss is the amount of memory shared with other processes, accounted in a way that the amount is divided evenly between the processes that share it. This is memory that would not be released if the process was terminated, but is indicative of the amount that this process is “contributing”.</p></blockquote><p>由于不同进程间会在内存中共同享有一些内存，如共享库，所以PSS可以综合考虑共享进程数，将共享库的内存占用按比例算入到进程名下。</p><blockquote><p>USS - Unique Set Size<br>Uss is the set of pages that are unique to a process. This is the amount of memory that would be freed if the application was terminated right now.</p></blockquote><p>USS则是进程单独占用的内存，如堆和栈都是不能给别人看的。</p><blockquote><p>The unshared memory (USS) plus a process’s proportion of shared memory is reported as the PSS (Proportional Set Size). The USS and PSS only include physical memory usage. They do not include memory that has been swapped out to disk.</p></blockquote><p>又根据上面<code>smem(8)</code>的描述可知，USS和PSS都不包含被置入交换区的部分。</p><p>所以一般来说有<code>VSS &gt;= RSS &gt;= PSS &gt;= USS</code>。</p><h2 id="一个计算例子"><a href="#一个计算例子" class="headerlink" title="一个计算例子"></a>一个计算例子</h2><p>假设有进程A，程序大小500K，链接共享库大小2500K，现在进程实际加载了共享库的1000K以及自身程序的400K，且堆栈大小200K，其中的100K被置入交换区，那么有：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VSS = 500K + 2500K + 200K = 3200K</span><br><span class="line">RSS = 400K + 1000K + 100K = 1500K</span><br><span class="line">PSS = 400K + 1000K/2 + 100K = 1000K <span class="comment"># 假设两个进程使用共享库</span></span><br><span class="line">USS = 400K + 100K = 500K</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>因为VSS还统计了进程尚未在内存中使用的大小（如进程<code>malloc</code>后，系统并不会第一时间分配内存）所以一般不用来衡量进程的内存占用；</li><li>而RSS因为将进程使用的共享库纳入统计，即使这个库能被复数进程共享，所以单独使用RSS作为测量项也会有误导性；</li><li>相对于RSS，PSS更适合作为进程内存占用的衡量项，而且<a href="https://unix.stackexchange.com/questions/34189/how-often-is-pss-value-updated-for-a-given-process-in-proc-pid-smaps" target="_blank" rel="noopener">不用担心PSS的更新时间</a>;</li><li>USS则非常适合用来采样观察进程是否发生了内存泄漏。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://linuxconfig.org/ps-output-difference-between-vsz-vs-rss-memory-usage" target="_blank" rel="noopener">https://linuxconfig.org/ps-output-difference-between-vsz-vs-rss-memory-usage</a></li><li><a href="https://elinux.org/Android_Memory_Usage" target="_blank" rel="noopener">https://elinux.org/Android_Memory_Usage</a></li><li><a href="https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management" target="_blank" rel="noopener">https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management</a></li><li><a href="https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate" target="_blank" rel="noopener">https://stackoverflow.com/questions/22372960/is-this-explanation-about-vss-rss-pss-uss-accurate</a></li><li><a href="https://www.jianshu.com/p/9bf36aa82f90" target="_blank" rel="noopener">https://www.jianshu.com/p/9bf36aa82f90</a></li><li><a href="https://linux.die.net/man/8/smem" target="_blank" rel="noopener">https://linux.die.net/man/8/smem</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;小白如我，写完程序想看看内存占用多少，打开了&lt;code&gt;top&lt;/code&gt;却不知道看哪一项为准。&lt;/p&gt;
&lt;h2 id=&quot;是什么？&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#4</title>
    <link href="https://joe-xu.github.io/2018/09/12/reading-the-go-programming-language-04/"/>
    <id>https://joe-xu.github.io/2018/09/12/reading-the-go-programming-language-04/</id>
    <published>2018-09-12T12:36:41.000Z</published>
    <updated>2018-09-24T13:26:00.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h2><h3 id="lt-P120-gt"><a href="#lt-P120-gt" class="headerlink" title="&lt; P120 &gt;"></a>&lt; P120 &gt;</h3><ul><li><p>函数传参都是值传递；在传递<code>slice</code>时，会复制一个<code>slice</code>的<code>struct</code>，包含了底层数组指针、<code>len</code>、<code>cap</code>，虽然被调用函数可以改变底层数组，但是其中<code>len</code>，<code>cap</code>等对调用者是不可见的，除非用指针或返回新值更新；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(val []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    val = <span class="built_in">append</span>(val, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(val []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    val = <span class="built_in">append</span>(val, <span class="number">321</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(val))</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    f1(val)</span><br><span class="line">    val = f2(val)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> val &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\t%d\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  1</span></span><br><span class="line"><span class="comment">//  0   321</span></span><br></pre></td></tr></table></figure></li><li><p>函数的类型又称作函数签名（signature），参数以及返回值的变量名对签名无影响；</p></li><li>Go的栈是可变的，取决于内存大小， 可以增长到数G；</li></ul><h3 id="lt-P125-gt"><a href="#lt-P125-gt" class="headerlink" title="&lt; P125 &gt;"></a>&lt; P125 &gt;</h3><ul><li>go的GC不会回收操作系统资源，如打开的文件、网络连接等，必须进行显式的回收；</li><li>当所有返回值都是具名的，return的操作数可以忽略，称作裸返回（bare return）；</li></ul><h3 id="lt-P134-gt"><a href="#lt-P134-gt" class="headerlink" title="&lt; P134 &gt;"></a>&lt; P134 &gt;</h3><ul><li>函数可以赋值，即函数可以作为参数传递；</li><li><p><code>%*s</code>中的<code>*</code>修饰符可以指定字符串前有多少空格；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%*s"</span>, <span class="number">5</span> , <span class="string">"text"</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="lt-P135-gt"><a href="#lt-P135-gt" class="headerlink" title="&lt; P135 &gt;"></a>&lt; P135 &gt;</h3><p>具名函数只能在包级定义；但是匿名函数可以在函数内部给函数变量赋值；但是如果需要递归调用，用<code>:=</code>定义函数变量会导致不能调用自身,可以尝试下面这种方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visitAll <span class="function"><span class="keyword">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">visitAll</span> = <span class="title">func</span><span class="params">(items []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">if</span> !seen[item] &#123;</span><br><span class="line">            seen[item] = <span class="literal">true</span></span><br><span class="line">            visitAll(m[item])</span><br><span class="line">            order = <span class="built_in">append</span>(order, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-P141-gt"><a href="#lt-P141-gt" class="headerlink" title="&lt; P141 &gt;"></a>&lt; P141 &gt;</h3><p>注意在使用闭包时捕获迭代局部变量的问题，应该用一个新的局部变量保存；</p><h3 id="lt-P144-gt"><a href="#lt-P144-gt" class="headerlink" title="&lt; P144 &gt;"></a>&lt; P144 &gt;</h3><ul><li>在运行到<code>defer</code>语句时，<em>deferred</em>的函数参数值就确定了，只有函数的执行被延迟；</li><li><em>Deferred</em>的函数在<code>return</code>之后执行；</li></ul><h3 id="lt-P151-gt"><a href="#lt-P151-gt" class="headerlink" title="&lt; P151 &gt;"></a>&lt; P151 &gt;</h3><p><em>Deferred</em>的函数调用的<code>runtime.Stack</code>方法可以打印<code>panic</code>时的<code>stack</code>是因为Go的<code>panic</code>机制会先运行<em>deferred function</em>再<em>unwind the stack</em>；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第五章-函数&quot;&gt;&lt;a href=&quot;#第五章-函数&quot; class=&quot;headerlink&quot; title=&quot;第五章 函数&quot;&gt;&lt;/a&gt;第五章 函数&lt;/h2&gt;&lt;h3 id=&quot;lt-P120-gt&quot;&gt;&lt;a href=&quot;#lt-P120-gt&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#3</title>
    <link href="https://joe-xu.github.io/2018/09/10/reading-the-go-programming-language-03/"/>
    <id>https://joe-xu.github.io/2018/09/10/reading-the-go-programming-language-03/</id>
    <published>2018-09-10T12:41:01.000Z</published>
    <updated>2018-09-24T13:17:53.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h2><h3 id="lt-P83-gt"><a href="#lt-P83-gt" class="headerlink" title="&lt; P83 &gt;"></a>&lt; P83 &gt;</h3><ul><li>长度亦算数组类型的一部分因此两个长度不同的数组是不同类型；</li><li>只有两个数组的元素类型可以比较时，这两个数组才可以比较；</li><li>调用函数传值时，会将数组拷贝传递（传值引用），所以在函数内的修改对原数组无影响；</li></ul><h3 id="lt-P86-gt"><a href="#lt-P86-gt" class="headerlink" title="&lt; P86 &gt;"></a>&lt; P86 &gt;</h3><ul><li>数组和切片声明时可以显式声明<em>index</em>，当两者混用时，隐式声明的元素<em>index</em>随前方相邻的显式声明<em>index</em>自增；</li><li><p>与数组不同，切片不能直接用<code>==</code>或<code>!=</code>比较，只有与<code>nil</code>的比较是合法的，除了<code>[]byte</code>可以用<code>bytes.Equal</code>方法比较外，其它类型切片我们都要自行逐个元素比较；</p><blockquote><p><a href="http://blog.csdn.net/erlib/article/details/50957218" target="_blank" rel="noopener">Go语言核心之美 3.2－slice切片</a><br>为什么Go语言不支持<code>slice</code>的比较运算呢？</p><ul><li>第一个原因，<code>slice</code>是引用类型，一个<code>slice</code>甚至可以引用自身。虽然有很多解决办法，但是没有一个是简单有效的;</li><li>第二个原因，因为<code>slice</code>是间接引用，因此一个<code>slice</code>在不同时间可能包含不同的元素－底层数组的元素可能被修改;</li><li>只要一个数据类型可以做相等比较，那么就可以用来做<code>map</code>的<em>key</em>,<code>map</code>这种数据结构对<em>key</em>的要求是：如果最开始时<em>key</em>是相等的，那在<code>map</code>的生命周期内，<em>key</em>要一直相等，因此这里<em>key</em>是不可变的。而对于指针或<code>chan</code>这类引用类型，<code>==</code>可以判断两个指针是否引用了想同的对象，是有用的，但是<code>slice</code>的相等测试充满了不确定性，因此，安全的做法是禁止<code>slice</code>之间的比较操作。</li></ul></blockquote></li><li><p>可以存在<code>len</code>和<code>cap</code>都为<code>0</code>但是<em>non-nil</em>的<code>slice</code>，所以判定<code>slice</code>是否为空应该用<code>len</code>;</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="lt-P94-gt"><a href="#lt-P94-gt" class="headerlink" title="&lt; P94 &gt;"></a>&lt; P94 &gt;</h3><ul><li><code>map</code>的键应该可以用<code>==</code>比较，不建议用浮点数作键；</li><li><p><code>map</code>中的元素不是变量，因此不能被取地址；</p><blockquote><p><code>map</code>可能会随着元素的增多重新分配更大的内存空间，旧值都会拷贝到新的内存空间，因此之前的地址就会失效。</p></blockquote></li><li><p>和切片一样，<code>map</code>间不能直接比较，只有和<code>nil</code>比较是合法的；</p></li></ul><h3 id="lt-P100-gt"><a href="#lt-P100-gt" class="headerlink" title="&lt; P100 &gt;"></a>&lt; P100 &gt;</h3><p>结构体的字段（field）可以取地址并通过指针访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Employee</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(EmployeeByID(dilbert.ManagerID).Position)   <span class="comment">// "Pointy-haired boss"</span></span><br><span class="line"></span><br><span class="line">id := dilbert.ID</span><br><span class="line">EmployeeByID(id).Salary = <span class="number">0</span> <span class="comment">// fired for... no real reason</span></span><br></pre></td></tr></table></figure><p>最后那条语句需要注意，它调用<code>EmployeeByID</code>生成了一个<code>*Employee</code>指针，然后直接更新该结构体中的一个字段。如果将<code>EmployeeByID</code>的返回值从<code>*Employee</code>换成<code>Employee</code>类型，那么编译将报错，因为编译器无法对返回的<code>Employee</code>进行寻址(<strong>不通过变量直接使用一个值，一般都无法进行寻址</strong>)。</p><h3 id="lt-P101-gt"><a href="#lt-P101-gt" class="headerlink" title="&lt; P101 &gt;"></a>&lt; P101 &gt;</h3><p><strong>对于结构体来说，字段顺序很重要，如果顺序不同或者有一些字段合并声明，即使字段名完全相同，那也算两个完全不同的结构体类型;</strong></p><h3 id="lt-P104-gt"><a href="#lt-P104-gt" class="headerlink" title="&lt; P104 &gt;"></a>&lt; P104 &gt;</h3><p>当结构体中所有字段都可以比较时，这个结构体类型才可以相比较；</p><h3 id="lt-P106-gt"><a href="#lt-P106-gt" class="headerlink" title="&lt; P106 &gt;"></a>&lt; P106 &gt;</h3><ul><li><p>准确来说，结构体中的匿名字段并不是真正的匿名，有隐式的与类型名相同的名字；在格式化字符串中加入<code>#</code>，<code>#</code>代表用Go的语法来打印。对于<code>struct</code>类型来说，打印中将包含每个字段的信息；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;   <span class="comment">//  or   w = Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>当匿名字段没有导出时，不能用长赋值形式；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  mStruct.go</span></span><br><span class="line"><span class="keyword">package</span> mStruct</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cyc <span class="keyword">struct</span> &#123;</span><br><span class="line">    point</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m = mStruct.Cyc&#123;&#125;</span><br><span class="line">    m.X = <span class="number">1</span></span><br><span class="line">    m.point.Y = <span class="number">2</span>   <span class="comment">//  cannot refer to unexported field or method point</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, m)  <span class="comment">//  mStruct.Cyc&#123;point:mStruct.point&#123;X:1, Y:0&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第四章-复合类型&quot;&gt;&lt;a href=&quot;#第四章-复合类型&quot; class=&quot;headerlink&quot; title=&quot;第四章 复合类型&quot;&gt;&lt;/a&gt;第四章 复合类型&lt;/h2&gt;&lt;h3 id=&quot;lt-P83-gt&quot;&gt;&lt;a href=&quot;#lt-P83-gt&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#2</title>
    <link href="https://joe-xu.github.io/2018/09/07/reading-the-go-programming-language-02/"/>
    <id>https://joe-xu.github.io/2018/09/07/reading-the-go-programming-language-02/</id>
    <published>2018-09-07T12:10:47.000Z</published>
    <updated>2018-09-24T13:56:56.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-基本数据类型"><a href="#第三章-基本数据类型" class="headerlink" title="第三章 基本数据类型"></a>第三章 基本数据类型</h2><p>主要围绕基本类型来讲的一章，仍记得当时看的时候按捺不住想要跳过的心，但是第三章还是非常重要的，有详细讲解最常用的<code>slice</code>内存模型避免误用，而且还穿插了一些有趣的小例程，譬如教你怎么画一个漂亮的分型图等。</p><p>但是这里我只post自己整理的笔记。XD</p><a id="more"></a><h3 id="lt-P52-gt"><a href="#lt-P52-gt" class="headerlink" title="&lt; P52 &gt;"></a>&lt; P52 &gt;</h3><ul><li><code>int</code>与<code>uint</code>的字节长度在不同实现的编译器下可能不同，即使是在同一个主机上；</li><li><code>%</code>仅能用于整型；</li><li>在Go中，余数符号永远与被除数相同，即<code>-5%3</code>与<code>-5%-3</code>同样得<code>-2</code>；</li></ul><h3 id="lt-P57-gt"><a href="#lt-P57-gt" class="headerlink" title="&lt; P57 &gt;"></a>&lt; P57 &gt;</h3><ul><li><p><code>float</code>类型变量为0时作被除数为<em>可疑运算（dubious operation）</em>，若用整型在编译时会报错，可以表示正负无穷以及<code>NaN</code>（not a number）；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float32</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z)  <span class="comment">// 0 -0 +Inf -Inf NaN</span></span><br></pre></td></tr></table></figure></li><li><p><code>math.NaN</code>函数也可以返回<code>NaN</code>，并且<code>NaN</code>的任何比较结果都是<code>false</code>，可以使用<code>math.IsNaN</code>函数判定；</p></li></ul><h3 id="lt-P63-gt"><a href="#lt-P63-gt" class="headerlink" title="&lt; P63 &gt;"></a>&lt; P63 &gt;</h3><ul><li>如果<code>s</code>是空字符串，使用<code>s[0</code>]会引起<code>panic</code>；</li><li>不存在<code>0</code>或<code>1</code>等到布尔类型的隐式转换，反过来同理；</li></ul><h3 id="lt-P65-gt"><a href="#lt-P65-gt" class="headerlink" title="&lt; P65 &gt;"></a>&lt; P65 &gt;</h3><ul><li>字符串的值是不可更改的，所以字符串拷贝和子字符串都可以与原串共用同一空间，操作廉价，但是<code>string</code>类型变量可以重新赋值；</li><li>内建函数<code>len</code>返回的是字符串的<code>byte</code>数，要在utf-8格式下计数可以用<code>utf8.RuneCountInString</code>方法；</li></ul><h3 id="lt-P70-gt"><a href="#lt-P70-gt" class="headerlink" title="&lt; P70 &gt;"></a>&lt; P70 &gt;</h3><ul><li><strong>使用<code>range</code>遍历字符串时，会隐式对utf8解码，索引<code>i</code>也会跳动</strong>；</li><li>每当utf8解码器遇到一个非预期的<code>byte</code>，不管是显式的调用<code>utf8.DecodeRuneInString</code>方法还是在<code>range</code>中隐式调用，会产生一个<em>replacement character</em>（\uFFFD），就是常见的黑底六角形加上白色问号的符号；</li></ul><h3 id="lt-P78-gt"><a href="#lt-P78-gt" class="headerlink" title="&lt; P78 &gt;"></a>&lt; P78 &gt;</h3><ul><li>经编译器处理，无类型常量的精度比基本类型更大，且四则运算同样，大约有256 bit的精度；</li><li>只有常量是无类型的，当常量被赋值给一个特定类型变量时会被隐式转换；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-基本数据类型&quot;&gt;&lt;a href=&quot;#第三章-基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本数据类型&quot;&gt;&lt;/a&gt;第三章 基本数据类型&lt;/h2&gt;&lt;p&gt;主要围绕基本类型来讲的一章，仍记得当时看的时候按捺不住想要跳过的心，但是第三章还是非常重要的，有详细讲解最常用的&lt;code&gt;slice&lt;/code&gt;内存模型避免误用，而且还穿插了一些有趣的小例程，譬如教你怎么画一个漂亮的分型图等。&lt;/p&gt;
&lt;p&gt;但是这里我只post自己整理的笔记。XD&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>说说login shell和non-login shell</title>
    <link href="https://joe-xu.github.io/2018/09/06/login-shell-and-non-login-shell/"/>
    <id>https://joe-xu.github.io/2018/09/06/login-shell-and-non-login-shell/</id>
    <published>2018-09-06T12:46:39.000Z</published>
    <updated>2018-09-19T13:10:28.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近又要在公司的CentOS上配一遍开发环境，这就避不了要编辑一番<code>PATH</code>，那么问题来了，这是要写在<code>/etc/profile</code>、<code>~/.profile</code>、<code>~/.bash_profile</code>还是<code>~/.bashrc</code>或<code>~/.bash_login</code>呢?首先，可以排除影响全局的<code>/etc/profile</code>，这改了听起来就是给后来的自己挖坑(还有一个<code>/etc/bash.bashrc</code>)。接着我们就要厘清后四个的区别了，这就要从<em>login shell</em>和<em>non-login shell</em>的区别说起。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不用Google，有事先找<code>man</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; man bash</span><br></pre></td></tr></table></figure><p>我们在<code>bash</code>的手册中<em>INVOCATION</em>一节就可以找到<em>login shell</em>的定义：</p><blockquote><p>A login shell is one whose first character of argument zero is a <code>-</code>, or one started with the <code>--login</code> option.</p></blockquote><p>顺便还有<em>interactive shell</em>的定义：</p><blockquote><p>An interactive shell is one started without non-option arguments and without the <code>-c</code> option whose standard input and error are both connected to terminals (as determined by  isatty(3)),  or one started with the <code>-i</code> option.</p></blockquote><p>可知有：</p><ul><li><em>交互式的 login shell</em>：本地登录、ssh登录、<code>bash --login</code>、<code>su - &lt;user&gt;</code>;</li><li><em>交互式的 non-login shell</em>：<code>su &lt;user&gt;</code>;</li><li><em>非交互的 non-login shell</em>：<code>ssh example.com my-script-which-is-on-the-remote-machine</code>;</li><li><em>非交互的 login shell</em>：脚本中使用<code>--login</code>(如<code>#!/bin/bash --login</code>);</li></ul><p>上述的情况并没有列全，可以通过如下方法区分login和non-login shell：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">-bash <span class="comment">#第一个字符是 "-"， 所以是 login shell。</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">bash <span class="comment">#不是一个login shell。</span></span><br></pre></td></tr></table></figure><h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>当一个<code>bash</code>是以<strong>交互式的login shell</strong>被调用时，它首先会读取<code>/etc/profile</code>文件，然后按照<code>~/.bash_profile</code>，<code>~/.bash_login</code>和<code>~/.profile</code>的顺序依次查找并读取，但这是短路式的，按顺序成功读取了三者之一就不继续往后查找了。最后在退出时会执行<code>~/.bash_logout</code>中的命令。</p><p>而<strong>交互式的non-login shell</strong>则先后读取<code>/etc/bash.bashrc</code>和<code>~/.bashrc</code>。</p><p><strong>非交互的non-login shell</strong>只展开环境变量<code>BASH_ENV</code>并执行其指向的文件。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>如果需要统一交互式的<em>login shell</em>和<em>non-login shell</em>环境，我们可以在<code>~/.bashrc</code>中编写配置，然后在<code>~/.bash_profile</code>读取<code>~/.bashrc</code>。非交互式的情况一般与脚本有关，一般是主动载入环境变量(因为环境变量问题，dockerfile中也建议使用绝对路径)，所以暂且不管。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://blog.sciencenet.cn/blog-3238131-1037461.html" target="_blank" rel="noopener">login shell与non-login shell的区别</a></li><li><a href="https://unix.stackexchange.com/questions/38175/difference-between-login-shell-and-non-login-shell" target="_blank" rel="noopener">difference-between-login-shell-and-non-login-shell</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近又要在公司的CentOS上配一遍开发环境，这就避不了要编辑一番&lt;code&gt;PATH&lt;/code&gt;，那么问题来了，这是要写在&lt;code&gt;/etc/profile&lt;/code&gt;、&lt;code&gt;~/.profile&lt;/code&gt;、&lt;code&gt;~/.bash_profile&lt;/code&gt;还是&lt;code&gt;~/.bashrc&lt;/code&gt;或&lt;code&gt;~/.bash_login&lt;/code&gt;呢?首先，可以排除影响全局的&lt;code&gt;/etc/profile&lt;/code&gt;，这改了听起来就是给后来的自己挖坑(还有一个&lt;code&gt;/etc/bash.bashrc&lt;/code&gt;)。接着我们就要厘清后四个的区别了，这就要从&lt;em&gt;login shell&lt;/em&gt;和&lt;em&gt;non-login shell&lt;/em&gt;的区别说起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://joe-xu.github.io/tags/Linux/"/>
    
      <category term="shell" scheme="https://joe-xu.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#1</title>
    <link href="https://joe-xu.github.io/2018/09/05/reading-the-go-programming-language-01/"/>
    <id>https://joe-xu.github.io/2018/09/05/reading-the-go-programming-language-01/</id>
    <published>2018-09-05T13:04:40.000Z</published>
    <updated>2018-09-24T13:57:41.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-程序结构"><a href="#第二章-程序结构" class="headerlink" title="第二章 程序结构"></a>第二章 程序结构</h2><h3 id="lt-P28-gt"><a href="#lt-P28-gt" class="headerlink" title="&lt; P28 &gt;"></a>&lt; P28 &gt;</h3><p>Go中的<a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">Predeclared identifiers</a>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Types:</span><br><span class="line">bool byte complex64 complex128 error float32 float64</span><br><span class="line">int int8 int16 int32 int64 rune string</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">Constants:</span><br><span class="line">true false iota</span><br><span class="line"></span><br><span class="line">Zero value:</span><br><span class="line">nil</span><br><span class="line"></span><br><span class="line">Functions:</span><br><span class="line">append cap close complex copy delete imag len</span><br><span class="line">make new panic print println real recover</span><br></pre></td></tr></table></figure><p>这里面的关键字都是不保留的，可以用作我们的自定变量名，当然这是强烈不推荐的。<del>除非已经被<em>命名困难症</em>逼到了绝境。</del></p><p>另外，变量名长度是不作限定的（the larger the scope of a name, the longer and more meanningful it should be），一个全局变量的名字应该比一个局部变量更易见名知义（所以长点也没关系）。</p><h3 id="lt-P31-gt"><a href="#lt-P31-gt" class="headerlink" title="&lt; P31 &gt;"></a>&lt; P31 &gt;</h3><ul><li><code>:=</code>(the short variable declaration)是用作声明的，而不是像<code>=</code>一样用作赋值；</li><li><code>:=</code>左边至少要存在一个未声明的变量；</li></ul><h3 id="lt-P35-gt"><a href="#lt-P35-gt" class="headerlink" title="&lt; P35 &gt;"></a>&lt; P35 &gt;</h3><p>如果两个变量的类型不承载任何信息，根据编译器的实现，指针地址可能相同，例如<code>struct{}</code>和<code>[0]int</code>；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> t2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, &amp;t1 == &amp;t2)   <span class="comment">//true  t1,t2为[0]int时同理</span></span><br></pre></td></tr></table></figure><h3 id="lt-P36-gt"><a href="#lt-P36-gt" class="headerlink" title="&lt; P36 &gt;"></a>&lt; P36 &gt;</h3><ul><li>用生命周期长的指针指向生命周期短的变量会阻碍对该变量的GC；</li><li><strong>变量被分配到堆或栈与否不由声明方式决定</strong>，如<code>var</code>或<code>new</code>；(mark一下，之后再拓展一篇，<del>如果还有机会看见这个mark</del>)</li></ul><h3 id="lt-P39-gt"><a href="#lt-P39-gt" class="headerlink" title="&lt; P39 &gt;"></a>&lt; P39 &gt;</h3><p>显式类型转换<code>T(x)</code>是一种<a href="https://golang.org/ref/spec#Conversions" target="_blank" rel="noopener">转换(conversion)</a>，不是函数调用；</p><h3 id="lt-P41-gt"><a href="#lt-P41-gt" class="headerlink" title="&lt; P41 &gt;"></a>&lt; P41 &gt;</h3><p>首先看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> x T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会隐式调用T的String方法（如果有）</span></span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>,x)</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>,x)</span><br><span class="line">fmt.Println(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会调用</span></span><br><span class="line">fmt.Printf(<span class="string">"%g"</span>,x)</span><br><span class="line">fmt.Println(<span class="keyword">float64</span>(x))</span><br></pre></td></tr></table></figure><p>那么我们在给<code>T</code>实现<code>String()</code>且需要打印自身时，要注意避免无穷递归调用。</p><h3 id="lt-P46-gt"><a href="#lt-P46-gt" class="headerlink" title="&lt; P46 &gt;"></a>&lt; P46 &gt;</h3><ul><li>变量的作用域与生命周期不相等，作用域是编译时属性(compile-time property)，而生命周期是运行时属性(run-time porperty)；</li><li><p>有或没有显式地用花括号界定的作用域都可以笼统地归纳为<em>lexical block</em>；例如包含整个源码的<em>universe <a href="https://golang.org/ref/spec#Blocks" target="_blank" rel="noopener">block</a></em>，每个<code>package</code>、文件、<code>for</code>、<code>if</code>、<code>switch/select</code>，<code>switch/select</code>中的每个<code>case</code>；</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">x := <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">for</span>  _ , x := <span class="keyword">range</span> x&#123;  <span class="comment">// for statement中有隐式lexical block</span></span><br><span class="line">x := x +<span class="string">'A'</span>-<span class="string">'a'</span>     <span class="comment">// &#123;&#125;中的显式lexical block</span></span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>,x)  <span class="comment">// 正常输出"HELLO"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导入的包的作用域是<em>file-level</em>的，所以每个文件都要单独导入，即使是同一个包下；</p></li><li><em>Control-flow label</em>（用于<code>break</code>、<code>continue</code>和<code>goto</code>）的作用域是整个函数；</li><li>编译器会从最内的<em>lexical block</em>至<em>universe block</em>查找变量的声明；所以最内部变量可以<em>shadow</em>（又或称屏蔽/<em>hide</em>）外部同名变量；</li></ul><h3 id="lt-P49-gt"><a href="#lt-P49-gt" class="headerlink" title="&lt; P49 &gt;"></a>&lt; P49 &gt;</h3><p><strong>在使用<code>:=</code>时要注意作用域</strong>；例如，如果要在函数内更新<em>package-level</em>变量，使用<code>:=</code>会重新声明一个同名局部变量；</p><h2 id="一段闲扯"><a href="#一段闲扯" class="headerlink" title="一段闲扯"></a>一段闲扯</h2><blockquote><p>！！距离拖延症发作过去了<strong>03</strong>天！！</p></blockquote><p>从第二章开始的内容已经比第一章多了，不过想想，这也是肯定的。按照这个劲头，似乎半个月就能把这个系列整理完。另外hexo是真的好用，都要治好我多年的拖延症了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二章-程序结构&quot;&gt;&lt;a href=&quot;#第二章-程序结构&quot; class=&quot;headerlink&quot; title=&quot;第二章 程序结构&quot;&gt;&lt;/a&gt;第二章 程序结构&lt;/h2&gt;&lt;h3 id=&quot;lt-P28-gt&quot;&gt;&lt;a href=&quot;#lt-P28-gt&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Go程序设计语言》读书笔记#0</title>
    <link href="https://joe-xu.github.io/2018/09/04/reading-the-go-programming-language/"/>
    <id>https://joe-xu.github.io/2018/09/04/reading-the-go-programming-language/</id>
    <published>2018-09-04T12:41:44.000Z</published>
    <updated>2018-09-05T13:19:27.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>当初入坑Go的时候，怀着朝圣的心买了这本书(<a href="https://book.douban.com/subject/26859123/" target="_blank" rel="noopener">《Go程序设计语言》</a>)来啃。本以为我这样的拖延症会拖到最后而不了了之，没想到硬是被我啃完了，因为书中的内容确实引人入胜，除了深入浅出讲解Go外，还有许多扩展开来的相关知识和编程思想。</p><a id="more"></a><p>在啃书途中，也用Onenote整理的不少的笔记，主要是一些关键知识的摘抄，打算在懒癌没发作的时间整理成一系列blog，希望能在年末前更新完十三章，届时可能能作为我18年的最自豪成绩。</p><p>日后如果温故而知新了，会继续追加更新。</p><p><del>要说为什么我当时用Onenote，因为年轻的我还是忠实的田牌教徒，用着田牌手机还要四处张扬那种。</del></p><h2 id="第一章-综述"><a href="#第一章-综述" class="headerlink" title="第一章 综述"></a>第一章 综述</h2><h3 id="lt-P6-gt"><a href="#lt-P6-gt" class="headerlink" title="&lt; P6 &gt;"></a>&lt; P6 &gt;</h3><p>Go中有statement与expression的区分</p><blockquote><p><a href="https://golang.org/ref/spec#Expressions" target="_blank" rel="noopener">Go Spec#Expressions</a>：<br>An expression specifies the computation of a value by applying operators and functions to operands.</p></blockquote><blockquote><p><a href="https://golang.org/ref/spec#Statements" target="_blank" rel="noopener">Go Spec#Statements</a>：<br>Statements control execution.</p></blockquote><p>那么，值得注意的是<code>i++</code>在go中是<code>statement</code>，不同于其它C-like语言。这就是<code>j = i++</code>等类似语句非法的原因。</p><h3 id="lt-P7-gt"><a href="#lt-P7-gt" class="headerlink" title="&lt; P7 &gt;"></a>&lt; P7 &gt;</h3><ul><li>用<code>+=</code>进行字符串拼接时会申请内存创建新的字符串，要注意频繁的操作会引起更密集的GC；</li></ul><h3 id="lt-P9-gt"><a href="#lt-P9-gt" class="headerlink" title="&lt; P9 &gt;"></a>&lt; P9 &gt;</h3><ul><li><code>map</code>是对<code>make()</code>创建的数据结构的引用；</li><li><code>map</code>里的键可以实任意可以使用<code>==</code>作比较的类型，而存储的值可以实任意类型；<blockquote><p><a href="https://golang.org/ref/spec#Comparison_operators" target="_blank" rel="noopener">扩展阅读：Go的Comparable rules</a></p></blockquote></li><li><code>map</code>是无序的，值得注意的是，<code>map</code>在使用<code>range</code>进行遍历的访问顺序亦是随机的，这应该算Go中最应该注意的坑之一了，据说这是在设计Go的时候有意为之的（<em>It’s not a bug, it’s a feature!</em>）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;当初入坑Go的时候，怀着朝圣的心买了这本书(&lt;a href=&quot;https://book.douban.com/subject/26859123/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Go程序设计语言》&lt;/a&gt;)来啃。本以为我这样的拖延症会拖到最后而不了了之，没想到硬是被我啃完了，因为书中的内容确实引人入胜，除了深入浅出讲解Go外，还有许多扩展开来的相关知识和编程思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://joe-xu.github.io/tags/Go/"/>
    
      <category term="读书笔记" scheme="https://joe-xu.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://joe-xu.github.io/2018/09/03/hello-world/"/>
    <id>https://joe-xu.github.io/2018/09/03/hello-world/</id>
    <published>2018-09-03T12:33:02.164Z</published>
    <updated>2018-09-03T12:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
